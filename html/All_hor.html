
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>All_hor</title><meta name="generator" content="MATLAB 9.11"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-03-29"><meta name="DC.source" content="All_hor.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Folders</a></li><li><a href="#3">Abbreviation</a></li><li><a href="#4">Acquisition Set-Up</a></li><li><a href="#5">Readjust data to Local Peak instead of FSR</a></li><li><a href="#6">Remove saturated data</a></li><li><a href="#7">Normalize EMG (make as a function instead)</a></li><li><a href="#8">Speed and aceleration (make as a function instead)</a></li><li><a href="#9">Cross correlation</a></li><li><a href="#10">Weighted data</a></li><li><a href="#11">Task 0.1 Simplify the matlab script</a></li><li><a href="#12">Task 0.2 Show average sweep for single subject</a></li><li><a href="#13">Task 0.3 Show individual sweep for single subject</a></li><li><a href="#14">Task 1.1 FC correlation with EMG (Seperate steps, Single subject)</a></li><li><a href="#15">Task 1.2 FC correlation with EMG (Assemble steps)</a></li><li><a href="#16">Task 1.3 FC correlation with EMG (slopes)</a></li><li><a href="#17">Speed vs EMG</a></li><li><a href="#18">Task 2.1 Within step adjustment of EMG acticity due to natural angle variation. (Single subject)</a></li><li><a href="#19">Task 2.2 Within step adjustment of EMG acticity due to natural angle variation. (Single subject)</a></li><li><a href="#20">Task 2.3 Within step adjustment of EMG acticity due to natural angle variation. (All subject)</a></li><li><a href="#21">Task 3.1 Horizontal perturbation.</a></li><li><a href="#22">Task 3.2 Horizontal perturbation boxplot</a></li><li><a href="#23">Task 4.1 Vertical perturbation</a></li><li><a href="#24">Task 5.0 Pre-baseline vs Post-baseline</a></li><li><a href="#25">Task 5.0 Show individual Unload trials</a></li><li><a href="#26">Task 6.0 make foot movement graph</a></li><li><a href="#27">finsihed</a></li></ul></div><pre class="codeinput">clc
clear;
close <span class="string">all</span>;
</pre><h2 id="2">Folders</h2><pre class="codeinput">included_vertical_data_processing = false;
<span class="keyword">if</span> included_vertical_data_processing == false
    msg = <span class="string">'Vertical data processing is disabled \n'</span>;
    fprintf(2,msg);
<span class="keyword">end</span>

fprintf(<span class="string">'script: Folder . . . '</span>); tic

names = [<span class="string">"thomas"</span>, <span class="string">"benedikte"</span>, <span class="string">"andreas"</span>,  <span class="string">"andrew"</span>, <span class="string">"gritt"</span>, <span class="string">"maria"</span>, <span class="string">"trine"</span>,  <span class="string">"trine2"</span>, <span class="string">"Christian"</span>, <span class="string">"Soeren"</span>]; <span class="comment">% "mia" excluded</span>
names_indiv = [<span class="string">"andreas"</span>, <span class="string">"andrew"</span>, <span class="string">"benedikte"</span>, <span class="string">"gritt"</span>, <span class="string">"maria"</span>, <span class="string">"thomas"</span>, <span class="string">"trine"</span>, <span class="string">"trine2"</span>]; <span class="comment">% "mia" excluded</span>
<span class="comment">% CTL2: andrew, Gritt, thomas, Mia, Trine, Trine 2</span>

<span class="comment">% Define data path</span>
addpath(<span class="string">"C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/FunctionFiles"</span>)

folderpath_preprocessed_data = <span class="string">"C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/data_preprocessed/"</span>;
folderpath_individuel_data = <span class="string">"C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/Indiv_data/"</span>;


<span class="comment">% Preallocation</span>
total_data = cell(1,1,numel(names));
total_type = cell(1,1,numel(names));
total_step = cell(1,1,numel(names));

<span class="keyword">if</span> included_vertical_data_processing
    <span class="comment">% Load vertical data</span>
    <span class="keyword">for</span> i = 1:numel(names_indiv)
        load(folderpath_individuel_data + names_indiv(i) + <span class="string">".mat"</span> );
        total_data_vertical{:,:,i} = data_indiv;

        load(folderpath_individuel_data + names_indiv(i) + <span class="string">"_type.mat"</span>);
        total_type_vertical{:,:,i} = type;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Load preproccessed data</span>
<span class="keyword">for</span> i = 1:length(names)
    load(folderpath_preprocessed_data + names(i) + <span class="string">"_data.mat"</span>);   total_data{:,:,i} = data; <span class="comment">% size(data) = [3,4]</span>
    <span class="comment">% example: data{protocol, sensor}(sweep, data number)</span>

    load(folderpath_preprocessed_data + names(i) + <span class="string">"_type.mat"</span>);   total_type{:,:,i} = type; <span class="comment">% size(type) = [1,4]</span>
    <span class="comment">% example: type{1:2} = [VER_yes, VER_no]; type{3:4} = [HOR_yes, HOR_no];</span>

    load(folderpath_preprocessed_data + names(i) + <span class="string">"_step.mat"</span>);   total_step{:,:,i} = step_index; <span class="comment">% size(step_index) = [3,1]</span>
    <span class="comment">% example: step_index{protocol}(sweep, step)</span>
<span class="keyword">end</span>

fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
</pre><pre class="codeoutput">Vertical data processing is disabled 
script: Folder . . . done [ 3.88 sec ] 
</pre><h2 id="3">Abbreviation</h2><pre class="codeinput">fprintf(<span class="string">'script: Abbreviation . . . '</span>); tic

<span class="comment">% protocol abbreviation types</span>
CTL = 1; VER = 2; HOR = 3; CTL2 = 4;
proto_all = [CTL, VER, HOR];

<span class="comment">% Sensor abbreviation type</span>
SOL = 1; TA = 2; ANG = 3; FSR = 4; time = 5; VEL = 6; ACC = 7;

<span class="comment">% Plotting labels</span>
labels = [<span class="string">"Soleus"</span>; <span class="string">"Tibialis"</span>; <span class="string">"Position"</span>; <span class="string">""</span>;  <span class="string">""</span>; <span class="string">"Velocity"</span>; <span class="string">"Acceleration"</span>];
labels_ms = [<span class="string">"Soleus"</span>+newline+<span class="string">"[\muV]"</span>;<span class="string">"Tibialis"</span>+newline+<span class="string">"[\muV]"</span>; <span class="string">"Position"</span>+newline+<span class="string">"[Deg]"</span>;  <span class="string">""</span>;  <span class="string">"Time"</span>+newline+<span class="string">"[ms]"</span>; <span class="string">"Velocity"</span>+newline+<span class="string">"[Deg/ms]"</span>;<span class="string">"Acceleration"</span>+newline+<span class="string">"[Deg/ms^2]"</span>];
labels_sec = [<span class="string">"Soleus"</span>+newline+<span class="string">"[\muV]"</span>;<span class="string">"Tibialis"</span>+newline+<span class="string">"[\muV]"</span>; <span class="string">"Position"</span>+newline+<span class="string">"[Deg]"</span>; <span class="string">""</span>;  <span class="string">"Time"</span>+newline+<span class="string">"[sec]"</span>;<span class="string">"Velocity"</span>+newline+<span class="string">"[Deg/s]"</span>;<span class="string">"Acceleration"</span>+newline+<span class="string">"[Deg/s^2]"</span>];

<span class="comment">% Global arrays</span>
align_with_obtions = [<span class="string">"second_begin"</span>, <span class="string">"four_begin"</span>, <span class="string">"six_begin"</span>];
steps_tested = [2,4,6];

<span class="comment">% Global function</span>
ms2sec = @(x) x*10^-3;         <span class="comment">% Ms to sec</span>
sec2ms = @(x) x*10^3;          <span class="comment">% Sec to ms</span>

<span class="comment">% Global window definition</span>
screensize = get(0,<span class="string">'ScreenSize'</span>);
width = screensize(3);
height = screensize(4);

fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
</pre><pre class="codeoutput">script: Abbreviation . . . done [ 0.00 sec ] 
</pre><h2 id="4">Acquisition Set-Up</h2><pre class="codeinput">fprintf(<span class="string">'script: Acquisition Set-Up . . . '</span>); tic;

sweep_length = 10;              <span class="comment">% Signal length in second</span>
Fs = 2000;                      <span class="comment">% Samples per second</span>
dt = 1/Fs;                      <span class="comment">% Seconds per sample</span>
pre_trig = 4;                   <span class="comment">% Pre-trigger</span>
N = Fs*sweep_length;            <span class="comment">% Total number of samples per signal</span>

fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
</pre><pre class="codeoutput">script: Acquisition Set-Up . . . done [ 0.00 sec ] 
</pre><h2 id="5">Readjust data to Local Peak instead of FSR</h2><pre class="codeinput">fprintf(<span class="string">'script: Readjust data to Local Peak instead of FSR . . .'</span>); tic
readjust = true;
show_gui = false;
gui_subject = 10;


<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
folderpath = <span class="string">"C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/Subject_offsets/"</span>;
filename = 1+<span class="string">"offset.mat"</span>;


error = zeros(numel(proto_all), numel(names),100); <span class="comment">% 3x10x100</span>
<span class="keyword">if</span> readjust
    <span class="keyword">for</span> sub = 1:numel(names) <span class="comment">% loop through subjects</span>
        <span class="comment">% Some subject only completed one protocol.</span>
        <span class="keyword">if</span> any(strcmp(names(sub), [<span class="string">"Christian"</span>, <span class="string">"Soeren"</span>]))
            protocols = [CTL];
        <span class="keyword">else</span>
            protocols = proto_all;
        <span class="keyword">end</span>

        <span class="comment">% Check if an already defined offset file exist for subject</span>
        filename = sub+<span class="string">"offset.mat"</span>;
        filepath = fullfile(folderpath, filename);
        <span class="keyword">if</span> exist(filepath, <span class="string">'file'</span>) == 2
            load(filepath) <span class="comment">% return 4x1 cell array called 'offset'</span>
            total_step{1,1,sub} = offset;

        <span class="comment">% Create offset automatically if no file exist</span>
        <span class="keyword">else</span>
            data = total_data{1,1,sub};         <span class="comment">% load data</span>
            step_index = total_step{1,1,sub};   <span class="comment">% load foot placement</span>
            <span class="keyword">for</span> proto = protocols
                <span class="keyword">for</span> sweep = 1:size(data{proto,ANG},1) <span class="comment">% loop through sweeps</span>
                    <span class="keyword">for</span> step = 1:3  <span class="comment">% loop through steps</span>

                        <span class="comment">% Find template around foot-strike</span>
                        [rise_num, ~] = func_find_edge(steps_tested(step));
                        rise_index = step_index{proto}(sweep, rise_num);
                        array = rise_index-400:rise_index+400;
                        template = data{proto,ANG}(sweep, array);
                        signal = data{proto,ANG}(sweep, :);

                        <span class="comment">% Peak inside template</span>
                        [pks, locs] = findpeaks(template, <span class="string">'MinPeakDistance'</span>, 200);
                        locs = locs + array(1);

                        <span class="comment">% Find the peak that follow the condition</span>
                        the_pks = 0; the_loc = 0;  <span class="comment">% peaks and locations</span>
                        <span class="keyword">for</span> i = 1:numel(locs) <span class="comment">% loop through locations</span>
                            <span class="keyword">if</span> pks(i) &gt; signal(locs(i) - 200) &amp;&amp; pks(i) &gt; signal(locs(i)+200)
                                the_pks = pks(i);
                                the_loc = locs(i);
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>

                        <span class="comment">% Update step_index or throw error</span>
                        <span class="keyword">if</span> the_pks == 0     <span class="comment">% non found: error</span>
                            error(proto,sub,sweep) = 1;
                        <span class="keyword">else</span>                <span class="comment">% no error</span>
                            step_index{proto}(sweep, rise_num) = the_loc;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span> <span class="comment">% step</span>
                <span class="keyword">end</span> <span class="comment">% sweep</span>

                <span class="comment">% Display no-peak idxs</span>
                temp = find(error(proto,sub,:) == 1);
                <span class="keyword">if</span> ~isempty(temp)
                    singleStr = string;
                    <span class="keyword">for</span> i = 1:numel(temp)
                        singleStr = singleStr + num2str(temp(i)) + <span class="string">" "</span>;
                    <span class="keyword">end</span>
                    msg = <span class="string">"\n     No peak found. Subject: "</span> + sub + <span class="string">". Sweep: "</span> + singleStr +  <span class="string">". Protocol: "</span> + proto + <span class="string">" "</span>;
                    fprintf(2,msg);
                <span class="keyword">end</span>
            <span class="keyword">end</span> <span class="comment">% proto</span>

        <span class="comment">% Save realigned data</span>
        total_data{1,1,sub} = data;
        total_step{1,1,sub} = step_index; <span class="comment">% update step_index</span>
        <span class="keyword">end</span> <span class="comment">% exist</span>
    <span class="keyword">end</span> <span class="comment">% sub</span>
    fprintf(<span class="string">'\n     done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>  <span class="comment">% readjust</span>


<span class="keyword">if</span> show_gui
    fprintf(<span class="string">'script: Re-adjust gui - [Waiting for user input]'</span>)
    data = total_data{1,1,gui_subject};

    filename = gui_subject+<span class="string">"offset.mat"</span>;
    filepath = fullfile(folderpath, filename);
    <span class="keyword">if</span> exist(filepath, <span class="string">'file'</span>) == 2
        load(filepath) <span class="comment">% return 4x1 cell array called 'offset'</span>
        step_index = offset;
    <span class="keyword">else</span>
        step_index = total_step{1,1,gui_subject}; <span class="comment">% update step_index</span>
    <span class="keyword">end</span>

    offset = [];    <span class="comment">% preparer for new input</span>
    readjustFSR     <span class="comment">% open gui</span>
    pause           <span class="comment">% wait for user input</span>

    <span class="keyword">if</span> ~isempty(offset)
        <span class="keyword">if</span> exist(filepath, <span class="string">'file'</span>) == 2
            prompt = newline + <span class="string">"Want to over save. YES: press &gt;y&lt;. NO, press &gt;n&lt;"</span>+ newline;
            correctInput = false;
            <span class="keyword">while</span> correctInput == false     <span class="comment">% Wait for correct user input</span>
                <span class="keyword">switch</span> input(prompt, <span class="string">'s'</span>)   <span class="comment">% Save user input</span>
                    <span class="keyword">case</span> <span class="string">"y"</span>
                        correctInput = true;
                        oversave = true;
                    <span class="keyword">case</span> <span class="string">"n"</span>
                        correctInput = true;
                        oversave = false;
                    <span class="keyword">otherwise</span>
                        correctInput = false;
                        warning(<span class="string">"Input not accepted"</span>)
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            oversave = true;
        <span class="keyword">end</span>

        <span class="keyword">if</span> oversave
            total_step{1,1,gui_subject} = offset;
            save(folderpath + gui_subject+<span class="string">"offset"</span>,<span class="string">'offset'</span>)
            disp(<span class="string">"Data saved"</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    fprintf(<span class="string">'gui done \n'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: Readjust data to Local Peak instead of FSR . . .
     done [ 0.03 sec ] 
</pre><h2 id="6">Remove saturated data</h2><pre class="codeinput">fprintf(<span class="string">'script: Remove saturated data . . .'</span>); tic

remove_saturated = true;    <span class="comment">% enable or disable</span>
threshold = -10;            <span class="comment">% remove ANG data if lower than</span>
span = [0, 20];             <span class="comment">% ms</span>

<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
<span class="keyword">if</span> remove_saturated

    <span class="comment">% From ms to samples</span>
    span = ms2sec(span)*Fs;        <span class="comment">% from ms to sample</span>
    exc_ctl = cell(size(names));    <span class="comment">% exclude Control</span>

    <span class="keyword">for</span> sub = 1:numel(names) <span class="comment">% loop through subjects</span>
        <span class="comment">% Load data</span>
        data = total_data{1,1,sub};
        step_index = total_step{1,1,sub};

        <span class="comment">% Find saturated idxs</span>
        <span class="keyword">for</span> sweep = 1:size(data{CTL,FSR},1) <span class="comment">% loop through sweeps</span>
            <span class="keyword">for</span> step = 1:3 <span class="comment">% loop through steps</span>
                [rise] = func_find_edge(steps_tested(step));
                edge = step_index{CTL}(sweep,rise);
                y = data{CTL,ANG}(sweep, span(1)+edge:span(2)+edge);
                <span class="keyword">if</span> any(find(y&lt;threshold))
                    exc_ctl{sub} = unique([exc_ctl{sub}, sweep]);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Remove saturated idxs</span>
        step_index{CTL}(exc_ctl{sub},:) = [];
        <span class="keyword">for</span> i = [SOL, TA, FSR, ANG]
            data{CTL,i}(exc_ctl{sub},:) = [];
        <span class="keyword">end</span>

        <span class="comment">% Display which step to remove</span>
        <span class="keyword">if</span> ~isempty( exc_ctl{sub} )
            msg = <span class="string">"\n     Saturated data. Subject: "</span> + sub + <span class="string">". Sweep: "</span> + num2str(exc_ctl{sub}) + <span class="string">" "</span>;
            fprintf(2,msg);

        <span class="keyword">end</span>

        <span class="comment">% Save data</span>
        total_data{1,1,sub} = data;
        total_step{1,1,sub} = step_index;
    <span class="keyword">end</span>

    fprintf(<span class="string">'\n     done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: Remove saturated data . . .
     Saturated data. Subject: 6. Sweep: 1  4  5  9 
     done [ 0.13 sec ] 
</pre><h2 id="7">Normalize EMG (make as a function instead)</h2><pre class="codeinput">fprintf(<span class="string">'script: Normalize EMG  . . . '</span>); tic;

normalize = true;      <span class="comment">% enable or disable</span>
span = 20;             <span class="comment">% how big is the smooth span.</span>
normalizing_step = 0;  <span class="comment">% which step is the data being normalized to [0,2,4]?</span>
norm_array_ms = [-800, -200];  <span class="comment">% normalize array, denoted in ms</span>


<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
<span class="keyword">if</span> normalize

    <span class="comment">% Normalize prebaseline control and horizontal</span>
    <span class="keyword">for</span> sub = 1:length(names) <span class="comment">% loop through subjects</span>
        <span class="comment">% Load data</span>
        data = total_data{1,1,sub};
        step_index = total_step{1,1,sub};

        <span class="keyword">if</span> ~any(strcmp(names(sub), [<span class="string">"Christian"</span>, <span class="string">"Soeren"</span>])) <span class="comment">% christian and soeren only completed the prebaseline protocol</span>
            [data, factor(sub,:)] = func_normalize_EMG(step_index, data, <span class="string">'protocols'</span>, [CTL,VER,HOR],  <span class="string">'normalize_to_step'</span>, normalizing_step,<span class="string">'span'</span>, span);
        <span class="keyword">else</span>
            [data] = func_normalize_EMG(step_index, data, <span class="string">'protocols'</span>, CTL,  <span class="string">'normalize_to_step'</span>, normalizing_step,<span class="string">'span'</span>, span);
        <span class="keyword">end</span>
        total_data{1,1,sub} = data; <span class="comment">% update data</span>
    <span class="keyword">end</span>

    <span class="comment">% Normalize vertical</span>
    <span class="keyword">if</span> included_vertical_data_processing
    <span class="keyword">for</span> sub = 1:numel(names_indiv)
        data = total_data_vertical{1,1,sub}; <span class="comment">% load data</span>
        type = total_type_vertical{1,1,sub}; no = type{2}; yes = type{1};
        x_axis = data{VER,time};
        temp1 = find(floor(norm_array_ms(1)) == x_axis);
        temp2 = find(floor(norm_array_ms(2)) == x_axis);
        norm_sample = [temp1, temp2(1)];

        sol_max = max(mean(data{VER,SOL}(no,norm_sample(1):norm_sample(2)),1));
        ta_max  = max(mean(data{VER,TA }(no,norm_sample(1):norm_sample(2)),1));

        <span class="keyword">for</span> sweep = 1:size(data{VER,SOL},1) <span class="comment">% sweep</span>
            data{VER,SOL}(sweep,:) = data{VER,SOL}(sweep,:)/sol_max;
            data{VER,TA }(sweep,:) = data{VER,TA }(sweep,:)/ta_max;
        <span class="keyword">end</span>
        total_data_vertical{1,1,sub} = data; <span class="comment">% save normalize</span>
    <span class="keyword">end</span>
    <span class="keyword">end</span>

    fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: Normalize EMG  . . . done [ 1.23 sec ] 
</pre><h2 id="8">Speed and aceleration (make as a function instead)</h2><pre class="codeinput">fprintf(<span class="string">'script: Speed and aceleration . . . '</span>); tic;

plot_data = false;          <span class="comment">% enable or disable plot</span>
span_position = 5;          <span class="comment">% inc. sample in guassian filter span</span>
span_velocity = 5;          <span class="comment">% inc. sample in guassian filter span</span>
span_acceleration = 10;     <span class="comment">% inc. sample in gaussian filter span</span>

<span class="comment">% Control and Horizontal trials</span>
<span class="keyword">for</span> sub = 1:length(names) <span class="comment">% subjects</span>
    data = total_data{1,1,sub};  <span class="comment">% load data</span>
    <span class="keyword">for</span> proto = proto_all <span class="comment">% protocols</span>

        <span class="comment">% Position</span>
        data{proto,ANG} = data{proto,ANG}.*4+25; <span class="comment">% rescale the signal;</span>
        pos = data{proto,ANG};
        <span class="comment">%data{proto,ANG} = smoothdata(data{proto,ANG}, 2, 'gaussian', span_position);    % gaussian smoothing</span>

        <span class="comment">% velocity</span>
        diffs1 = diff(data{proto,ANG}, 1, 2)./(dt*10^3);            <span class="comment">% [deg/sample]</span>
        diffs1 = padarray(diffs1, [0 1], <span class="string">'post'</span>);                   <span class="comment">% zeropadding</span>
        data{proto,VEL} = smoothdata(diffs1, 2, <span class="string">'gaussian'</span>, span_velocity);    <span class="comment">% gaussian smoothing</span>
        clear <span class="string">diffs1</span>

        <span class="comment">% acceleration</span>
        diffs2 = diff(data{proto,VEL}, 1, 2)./(dt*10^3);            <span class="comment">% [deg/sample^2]</span>
        diffs2 = padarray(diffs2, [0 1], <span class="string">'post'</span>);                   <span class="comment">% zeropadding</span>
        data{proto,ACC} = smoothdata(diffs2, 2, <span class="string">'gaussian'</span>, span_acceleration);    <span class="comment">% gaussian smoothing</span>
        clear <span class="string">diffs2</span>

        <span class="comment">% Need to plot before and after</span>
        <span class="keyword">if</span> plot_data == 1 &amp;&amp; sub == 1
            step_index = total_step{1,1,sub};
            sweep = 1; dur = 1000; before = 500;
            [rise, ~] = func_find_edge(4);
            rise_index = step_index{CTL}(sweep,rise);
            display_array = rise_index-before:rise_index+dur;

            figure; hold <span class="string">on</span>
            subplot(311)
            plot(display_array, pos(1,display_array),<span class="string">'-o'</span>, display_array, data{proto,ANG}(sweep,display_array),<span class="string">'-x'</span>)
            legend([<span class="string">"raw"</span>, <span class="string">"filtered"</span>])

            subplot(312)
            plot(display_array, diffs1(1,display_array),<span class="string">'-o'</span>,display_array, data{proto,VEL}(sweep,display_array),<span class="string">'-x'</span>)
            legend([<span class="string">"raw"</span>, <span class="string">"filtered"</span>])

            subplot(313)
            plot(display_array, diffs2(1,display_array),<span class="string">'-o'</span>, display_array, data{proto,ACC}(sweep,display_array),<span class="string">'-x'</span>)
            legend([<span class="string">"raw"</span>, <span class="string">"filtered"</span>])

        <span class="keyword">end</span>
    <span class="keyword">end</span>
    total_data{1,1,sub} = data;
<span class="keyword">end</span>

<span class="keyword">if</span> included_vertical_data_processing
<span class="comment">% Vertical perturbation</span>
<span class="keyword">for</span> sub = 1:numel(names_indiv)
    data = total_data_vertical{1,1,sub};
    <span class="keyword">for</span> i = 1:size(data{VER,1},1) <span class="comment">% sweeps</span>

        <span class="comment">% Position [d]</span>
        <span class="comment">%data{VER,ANG} = data{VER,ANG}.*4+25;                % rescale the signal;</span>

        <span class="comment">% Velocity [d/s]</span>
        diffs1 = diff(data{VER,ANG}, 1, 2)./(dt*10^3);      <span class="comment">% [deg/sample]</span>
        diffs1 = padarray(diffs1, [0 1], <span class="string">'post'</span>);           <span class="comment">% zeropadding</span>
        data{VER,VEL} = smoothdata(diffs1, 2, <span class="string">'gaussian'</span>, span_velocity);       <span class="comment">% gaussian smoothing</span>

        <span class="comment">% Acceleration [d/s^2]</span>
        diffs2 = diff(data{VER,VEL}, 1, 2)./(dt*10^3);      <span class="comment">% [deg/sample^2]</span>
        diffs2 = padarray(diffs2, [0 1], <span class="string">'post'</span>);           <span class="comment">% zeropadding</span>
        data{VER,ACC} = smoothdata(diffs2, 2, <span class="string">'gaussian'</span>, span_acceleration);   <span class="comment">% gaussian smoothing</span>

    <span class="keyword">end</span>
    total_data_vertical{1,1,sub} = data;
<span class="keyword">end</span>
<span class="keyword">end</span>
fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
</pre><pre class="codeoutput">script: Speed and aceleration . . . done [ 3.74 sec ] 
</pre><h2 id="9">Cross correlation</h2><pre class="codeinput">fprintf(<span class="string">'script: Cross correlation  . . . '</span>); tic

croos_bool = true;
templ_array = [500:1500];     <span class="comment">% template array, denoted in samples</span>
show_cross = false;
subject = 4;


<span class="keyword">if</span> croos_bool &amp;&amp; included_vertical_data_processing
    <span class="keyword">for</span> sub = 1:numel(names_indiv)
        <span class="comment">% Load data</span>
        data = total_data_vertical{1,1,sub};
        type = total_type_vertical{1,1,sub}; no = type{2}; yes = type{1};
        x_axis = data{VER,time};

        <span class="comment">% Re-align - cross correlation</span>
        y_yes =  mean(data{VER,SOL}(yes,:),1);
        y_no = mean(data{VER,SOL}(no,:),1);
        template = mean(data{VER,SOL}(no,templ_array),1);
        [rx, lags] = xcorr(y_yes, template);  <span class="comment">% Cross-correlation</span>

        <span class="comment">% Re-align - find Peaks</span>
        [pks, locs] = findpeaks(rescale(rx), <span class="string">'MinPeakDistance'</span>, 500);
        tmp = find(lags(locs) &gt; 0);
        pks = pks(tmp);
        locs = locs(tmp);
        delay = templ_array(1)-lags(locs(1)); <span class="comment">% denoted in samples</span>
        delay_ms = sec2ms(delay*dt);

        <span class="comment">% Re-align - actual</span>
        <span class="keyword">for</span> sweep = 1:numel(no)
            <span class="keyword">for</span> type = [SOL, TA, ANG, VEL]
                data{VER,type}(no(sweep),:) = [data{VER,type}(no(sweep),delay+1:end), zeros(1, delay)];
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Show cross correlation</span>
        <span class="keyword">if</span> and(show_cross, sub == subject)


            <span class="comment">% Check if a figure with the name 'TASK3' is open</span>
            fig = findobj(<span class="string">'Name'</span>, <span class="string">'Cross correlation'</span>);
            <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>

            figure(<span class="string">'name'</span>, <span class="string">'Cross correlation'</span>);
            subplot(311); hold <span class="string">on</span>
                plot(templ_array, template, <span class="string">'color'</span>, [0.7, 0.7, 0.7], <span class="string">'LineWidth'</span>, 5 )
                plot(y_no, <span class="string">'color'</span>, <span class="string">"blue"</span>, <span class="string">'LineWidth'</span>, 2)
                plot(y_yes, <span class="string">'color'</span>, <span class="string">'black'</span>)
                title(<span class="string">"before"</span>)
            subplot(312); hold <span class="string">on</span>
                title(<span class="string">"Cross correlation"</span>)
                N = numel(y_yes);
                plot(lags(locs(1)):lags(locs(1))+numel(template)-1, template, <span class="string">'color'</span>, [0.7, 0.7, 0.7], <span class="string">'LineWidth'</span>, 5);
                plot(0:N-1, y_yes, <span class="string">'color'</span>, <span class="string">'black'</span>)
                plot(lags, rescale(rx), <span class="string">'color'</span>, <span class="string">'blue'</span>);
                plot(lags(locs), pks, <span class="string">'rx'</span>, <span class="string">'linewidth'</span>, 1);
                plot(lags(locs(1)), pks(1), <span class="string">'o'</span>);
                plot([lags(locs(1)), lags(locs(1))], [0,pks(1) ])
            subplot(313); hold <span class="string">on</span>
                title(<span class="string">"After"</span>)
                plot(mean(data{VER,SOL}(no,:),1), <span class="string">'color'</span>, <span class="string">"blue"</span>, <span class="string">'LineWidth'</span>, 2)
                plot(mean(data{VER,SOL}(yes ,:),1), <span class="string">'color'</span>, <span class="string">'black'</span>, <span class="string">'LineWidth'</span>, 1)
        <span class="keyword">end</span>

        <span class="comment">% Save data</span>
        total_data_vertical{1,1,sub} = data;
    <span class="keyword">end</span>
    fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: Cross correlation  . . . disable 
</pre><h2 id="10">Weighted data</h2><pre class="codeinput">fprintf(<span class="string">'script: weighting_data  . . . '</span>); tic

weighting_data = true;

<span class="keyword">if</span> weighting_data

    <span class="comment">% Find the subject with smallest subject size</span>
    threshold = 50;
    <span class="keyword">for</span> sub = 1:numel(names)
        data = total_data{1,1,sub};
        sub_size = size(data{CTL,ANG},1); <span class="comment">% sweep size</span>
        <span class="keyword">if</span> threshold &gt; sub_size; threshold = sub_size; <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Remove sweeps larger than smallest subject size</span>
    <span class="keyword">for</span> sub = 1:numel(names)
        data = total_data{1,1,sub};         <span class="comment">% load data</span>
        step_index = total_step{1,1,sub};   <span class="comment">% load data</span>
        sub_size = size(data{CTL,ANG},1);   <span class="comment">% sweep size</span>
        <span class="keyword">if</span> sub_size &gt; threshold
            step_index{CTL}(threshold+1:end,:) = [];
            <span class="keyword">for</span> i = [SOL, TA, FSR, ANG]
                data{CTL,i}(threshold+1:end,:) = [];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        total_data{1,1,sub} = data;         <span class="comment">% save data</span>
        total_step{1,1,sub} = step_index;   <span class="comment">% save data</span>
    <span class="keyword">end</span>
    fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: weighting_data  . . . done [ 0.18 sec ] 
</pre><h2 id="11">Task 0.1 Simplify the matlab script</h2><p>Make the script accessible to be navigated by Andrew and Thomas. - clearify parameters meant to be adjusted. - make passive code as function and remove.</p><h2 id="12">Task 0.2 Show average sweep for single subject</h2><pre class="codeinput">fprintf(<span class="string">'script: TASK 0.2  . . . '</span>);

show_plot = false;      <span class="comment">% Disable or enable plot</span>
subject = 10;            <span class="comment">% Obtions: 1:8</span>
proto = CTL;            <span class="comment">% Obtions: CTL, VER, HOR</span>
str_sen = [<span class="string">"Position"</span>, <span class="string">"Soleus"</span>, <span class="string">"Tibialis"</span>];    <span class="comment">% Obtions: "Soleus", "Tibialis","Position", "Velocity", "Acceleration";</span>
show_FSR = true;

align_bool = true;      <span class="comment">% Should the data be aligned with step specified in "Align with specific Stair step"</span>
    alignWithStep = align_with_obtions(1) ;
    before = 200;
    after = 100;

<span class="comment">% .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
<span class="keyword">if</span> show_plot
fprintf(<span class="string">' plot subject: &gt;&gt; '</span> + names(subject) + <span class="string">' &lt;&lt; \n'</span> );

<span class="keyword">if</span> align_bool
    <span class="comment">% Load data and align with defined step</span>
    data = total_data{1,1,subject};
    step_index = total_step{1,1,subject};
    temp = cell(3,7);
    [temp{proto,:}] = func_align(step_index{proto}, data{proto,[1:4,6:7]}, <span class="string">'sec_before'</span>, ms2sec(before), <span class="string">'sec_after'</span>, ms2sec(after), <span class="string">'alignStep'</span>, alignWithStep);
    clear <span class="string">data</span>
    data = temp;
    x_axis = data{proto,time};
    x_axis = sec2ms(x_axis);
    str_xlabel = <span class="string">"Time [ms]"</span> + newline + <span class="string">"Data normalized to step four"</span>;
<span class="keyword">else</span>
    <span class="comment">% Load data</span>
    data = total_data{1,1,subject};
    x_axis = linspace(-4, 6-dt, N);
    x_axis = sec2ms(x_axis);
    str_xlabel = <span class="string">"Time [ms]"</span> + newline + <span class="string">"Data normalized to Force-Platform"</span>;
<span class="keyword">end</span>

<span class="keyword">switch</span> proto
    <span class="keyword">case</span> HOR
        type = total_type{:,:,subject};
        yes = type{3}; no = type{4}; str_title = <span class="string">"Horizontal perturbation"</span>;
    <span class="keyword">case</span> VER
        type = total_type{:,:,subject};
        yes = type{1}; no = type{2}; str_title = <span class="string">"Vertical perturbation"</span>;
    <span class="keyword">case</span> {CTL}
        str_title = <span class="string">"Pre-baseline Control"</span>;
<span class="keyword">end</span>

figure;
    sgtitle(str_title + <span class="string">" - subject "</span> + names(subject));
    <span class="keyword">for</span> i = 1:size(str_sen,2) <span class="comment">% check and plot data included in str_sen</span>
        <span class="keyword">switch</span> str_sen(i)
            <span class="keyword">case</span> <span class="string">"Soleus"</span>
                sensor_modality = SOL;
                str_ylabel = <span class="string">"Soleus"</span> + newline + <span class="string">"[\muV]"</span>;
            <span class="keyword">case</span> <span class="string">"Tibialis"</span>
                sensor_modality = TA;
                str_ylabel = <span class="string">"Tibialis"</span>+newline+<span class="string">"[\muV]"</span>;
            <span class="keyword">case</span> <span class="string">"Position"</span>
                sensor_modality = ANG;
                str_ylabel = <span class="string">"Position"</span> + newline + <span class="string">"[Deg]"</span> + newline + <span class="string">"[Dorsal] &lt;  &gt; [Plantar]"</span>;
            <span class="keyword">case</span> <span class="string">"Velocity"</span>
                sensor_modality = VEL;
                str_ylabel = <span class="string">"Velocity"</span> + newline + <span class="string">"[Deg/s]"</span>;
            <span class="keyword">case</span> <span class="string">"Acceleration"</span>
                sensor_modality = ACC;
                str_ylabel = <span class="string">"Acceleration "</span> + newline + <span class="string">"[Deg/s^2]"</span>;
             <span class="keyword">otherwise</span>
                disp(<span class="string">"ERROR"</span> + newline + <span class="string">"String: &gt;&gt;"</span> + str_sen(i) + <span class="string">"&lt;&lt; is not registered."</span>)
        <span class="keyword">end</span>

        <span class="keyword">switch</span> proto
            <span class="keyword">case</span> {VER, HOR}
                subplot(size(str_sen,2)*100 + 10 + i); hold <span class="string">on</span>; ylabel(str_ylabel);
                plot(x_axis, mean(data{proto,sensor_modality}(no,:),1), <span class="string">"LineWidth"</span>,3, <span class="string">"color"</span>,[0.75, 0.75, 0.75])
                plot(x_axis, mean(data{proto,sensor_modality}(yes,:),1), <span class="string">"LineWidth"</span>,1, <span class="string">"color"</span>,<span class="string">"black"</span>)

                <span class="keyword">if</span> show_FSR
                    y_fsr = rescale(mean(data{proto,FSR},1));
                    yyaxis <span class="string">right</span>; ylabel(<span class="string">"Phase"</span>); ylim([-0.1 1.1])
                    plot(x_axis, y_fsr, <span class="string">"color"</span>,	<span class="string">"yellow"</span>);
                <span class="keyword">end</span>

            <span class="keyword">case</span> {CTL, CTL2}
                subplot(size(str_sen,2)*100 + 10 + i); hold <span class="string">on</span>; ylabel(str_ylabel);
                <span class="comment">% plt std around mean</span>
                y = mean(data{proto,sensor_modality},1);
                std_dev = std(data{proto,sensor_modality});
                curve1 = y + std_dev;
                curve2 = y - std_dev;
                x2 = [x_axis, fliplr(x_axis)];
                inBetween = [curve1, fliplr(curve2)];
                fill(x2, inBetween, [0.75, 0.75, 0.75], <span class="string">'LineStyle'</span>,<span class="string">'none'</span>);
                plot(x_axis, y, <span class="string">'LineWidth'</span>, 2, <span class="string">"color"</span>,<span class="string">"black"</span>);

                <span class="keyword">if</span> show_FSR <span class="comment">% show FSR if enabled</span>
                    y_fsr = rescale(mean(data{proto,FSR},1));
                    yyaxis <span class="string">right</span>; ylabel(<span class="string">"Phase"</span>); ylim([-0.1 1.1])
                    plot(x_axis, y_fsr, <span class="string">"color"</span>,	<span class="string">"yellow"</span>);
                <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> i == size(str_sen,2)
            xlabel(str_xlabel)
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    clear <span class="string">y_fsr</span>
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: TASK 0.2  . . . disable 
</pre><h2 id="13">Task 0.3 Show individual sweep for single subject</h2><p>unders&oslash;g for metodisk fejl.</p><pre class="codeinput">fprintf(<span class="string">'script: TASK 0.3  . . . '</span>);

show_plot = false;       <span class="comment">% Disable or enable plot</span>
subject = 10;           <span class="comment">% Obtions: 1:9</span>
proto = CTL;            <span class="comment">% Obtions: CTL</span>
sensor_modality = SOL;  <span class="comment">% Obtions: SOL, TA, ANG, VEL, ACC</span>
before = 50;            <span class="comment">% before foot strike included in ms</span>
after = 0;              <span class="comment">% after foot lift-off included in ms</span>

<span class="comment">% .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
<span class="keyword">if</span> show_plot
fprintf(<span class="string">'plot subject: &gt;&gt; '</span> + names(subject) + <span class="string">' &lt;&lt; \n'</span> );
data = total_data{1,1,subject};
step_index = total_step{1,1,subject};
x_axis_total = linspace(-4, 6-dt, N); <span class="comment">% time axis</span>
sweepNum = size(data{proto,ANG},1);   <span class="comment">% total sweep size</span>


figure(<span class="string">'name'</span>,<span class="string">'control sweep'</span>); <span class="comment">% Begin plot</span>
    loop = true; sweep = 1;
    <span class="keyword">while</span> loop == true
        clc <span class="comment">% clear cmd promt</span>
        sgtitle(<span class="string">"Sweep: "</span> + sweep) <span class="comment">% display current sweep in promt</span>

        subplot(211);
        <span class="comment">% plot data</span>
        yyaxis <span class="string">left</span>;
        plot(x_axis_total, mean(data{proto,sensor_modality},1), <span class="string">'-'</span>, <span class="string">"LineWidth"</span>,3, <span class="string">"color"</span>,[0.75, 0.75, 0.75]) <span class="comment">% mean plt</span>
        hold <span class="string">on</span>
        plot(x_axis_total, data{proto,sensor_modality}(sweep,:), <span class="string">'-'</span>, <span class="string">"LineWidth"</span>,1, <span class="string">"color"</span>,<span class="string">"black"</span>) <span class="comment">% sweep plt</span>
        hold <span class="string">off</span>

        <span class="comment">% plt formalia</span>
        xlabel(<span class="string">"Time"</span>+newline+<span class="string">"[sec]"</span>)
        ylabel(labels_ms(sensor_modality))
        title([<span class="string">'Black graph, Sweep data. {\color{gray} Gray graph, Mean data [n='</span> num2str(sweepNum) <span class="string">'].}'</span>])

        <span class="keyword">if</span> show_FSR
            y_fsr = rescale(data{proto,FSR}(sweep,:));
            yyaxis <span class="string">right</span>; ylabel(<span class="string">"Phase"</span>); ylim([-0.1 1.1]);
            plot(x_axis_total,y_fsr, <span class="string">"color"</span>,	<span class="string">"red"</span>);
        <span class="keyword">end</span>

        <span class="comment">% Define the data for each step</span>
        clear <span class="string">y</span>
        <span class="keyword">for</span> k = 1:3
            clear <span class="string">data_align</span>
            data_align = cell(3,7);
            [data_align{proto,:}] = func_align(step_index{proto}, data{proto,[1:4,6:7]}, <span class="string">'sec_before'</span>, ms2sec(before), <span class="string">'sec_after'</span>, ms2sec(after), <span class="string">'alignStep'</span>, align_with_obtions(k));
            x_axis = data_align{proto,time};
            y{k,2} = sec2ms(x_axis);
            y{k,1} = data_align{proto,sensor_modality}(sweep,:);
            y{k,3} = mean(data_align{proto,sensor_modality},1);
        <span class="keyword">end</span>

        <span class="comment">% plot data for each step</span>
        <span class="keyword">for</span> k = 1:3 <span class="comment">% loop through steps</span>
            subplot(233+k); hold <span class="string">on</span>;
            <span class="keyword">if</span> sensor_modality == or(SOL,TA)
                ylim([0 ceil(max([max(y{1,1}),  max(y{2,1}), max(y{3,1})])/100)*100])
            <span class="keyword">end</span>
            plot(y{k,2}, y{k,3}, <span class="string">"LineWidth"</span>,2, <span class="string">"color"</span>, [0.75, 0.75, 0.75]) <span class="comment">% Mean</span>
            plot(y{k,2}, y{k,1}, <span class="string">"LineWidth"</span>,1, <span class="string">"color"</span>,<span class="string">"black"</span>) <span class="comment">% Sweep</span>
            ylim <span class="string">auto</span>
            YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)]);
            plot([0, 0],[YL(1) YL(2)], <span class="string">"--"</span>,<span class="string">"LineWidth"</span>,1, <span class="string">"Color"</span>, <span class="string">"red"</span>) <span class="comment">% plt fsr</span>

            <span class="comment">% plt formalia</span>
            xlabel(<span class="string">"Time"</span>+newline+<span class="string">"[ms]"</span>)
            title(<span class="string">"Step: "</span> + steps_tested(k))
            ylabel(labels_ms(sensor_modality))
        <span class="keyword">end</span>

        <span class="comment">% Wait for user input</span>
        correctInput = false;
        prompt = <span class="string">"Continue, press &gt;c&lt;"</span> + newline + <span class="string">"Quite, press &gt;q&lt;"</span>+ newline + <span class="string">"Change sweep number, press &gt;t&lt;"</span>+ newline;
        <span class="keyword">while</span> correctInput == false     <span class="comment">% Wait for correct user input</span>
            str = input(prompt, <span class="string">'s'</span>);   <span class="comment">% Save user input</span>
            <span class="keyword">if</span> strcmp(str,<span class="string">"q"</span>)          <span class="comment">% If pressed - Quite the loop</span>
                disp(<span class="string">"Loop stopped"</span>)
                loop = false; correctInput = true;
                fig = findobj(<span class="string">'Name'</span>, <span class="string">'control sweep'</span>);
                <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
            <span class="keyword">elseif</span> strcmp(str,<span class="string">"t"</span>)      <span class="comment">% If pressed - Change sweep number</span>
                sweep = input(<span class="string">"New sweep number: "</span>)-1;
                correctInput = true;
            <span class="keyword">elseif</span> strcmp(str,<span class="string">"c"</span>)      <span class="comment">% If pressed - Continue to next sweep</span>
                correctInput = true;
            <span class="keyword">end</span>

            <span class="keyword">if</span> correctInput == false
                warning(<span class="string">"Input not accepted"</span>)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        sweep = sweep + 1; <span class="comment">% Continue to next sweep</span>
        <span class="keyword">if</span> sweep &gt; size(data{proto,sensor_modality},1) <span class="comment">% stop loop if max sweep reached</span>
            loop = false;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    fprintf(<span class="string">'disable'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: TASK 0.3  . . . disable</pre><h2 id="14">Task 1.1 FC correlation with EMG (Seperate steps, Single subject)</h2><p>Find individuelle outliner og unders&oslash;g for refleks response.</p><pre class="codeinput">fprintf(<span class="string">'\nscript: TASK 1.1  . . . '</span>); tic

show_plot = false;           <span class="comment">% plot the following figures for this task</span>
subject = 4;                <span class="comment">% subject to analyse</span>
protocol = CTL;                <span class="comment">% Only works for pre and post baseline trials</span>
before = 200;
after = 50;
xlimits = [-before 300];
savepgn = false;
inc_sub = [1,2,3,4,5,7,8,9,10]; <span class="comment">% Exclude sub 6</span>

<span class="comment">% .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>

<span class="comment">% General search bars:</span>
dep_off = 39; dep_len = 20;
step = 2; predict_search(step,:) = [0,20]; depend_search(step,:) = [predict_search(step,1)+dep_off,predict_search(step,1)+dep_off+dep_len];    <span class="comment">% ms</span>
step = 4; predict_search(step,:) = [0,20]; depend_search(step,:) = [predict_search(step,1)+dep_off,predict_search(step,1)+dep_off+dep_len];    <span class="comment">% ms</span>
step = 6; predict_search(step,:) = [0,20]; depend_search(step,:) = [predict_search(step,1)+dep_off,predict_search(step,1)+dep_off+dep_len];    <span class="comment">% ms</span>

<span class="comment">% Preallocation</span>
predictor_value = cell(size(names));
depended_value = cell(size(names));

<span class="keyword">for</span> sub = inc_sub   <span class="comment">% loop through subjects</span>
    <span class="keyword">if</span> ~readjust    <span class="comment">% readjust disabled. Manuel search-bars applied</span>
        <span class="keyword">switch</span> sub
        <span class="keyword">case</span> 1
            predict_search(2,:) = [1.5,1.5+20];  depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [-0.5,20-0.5]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [-2,20-2];     depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    <span class="comment">% ms</span>
        <span class="keyword">case</span> 2
            predict_search(2,:) = [-12,20-12];   depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [3,20-3];      depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];  <span class="comment">% ms</span>
            predict_search(6,:) = [-4.5,20-4.5]; depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_off];   <span class="comment">% ms</span>
        <span class="keyword">case</span> 3
            predict_search(2,:) = [0.5, 20+0.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];   <span class="comment">% ms</span>
            predict_search(4,:) = [1.5, 1.5+20]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [3, 3+20];     depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];   <span class="comment">% ms</span>
        <span class="keyword">case</span> 4
            predict_search(2,:) = [-4.5, 20-4.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [-5.5, 20-5.5]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [-6.5, 20-6.5]; depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    <span class="comment">% ms</span>
        <span class="keyword">case</span> 5
            predict_search(2,:) = [2, 2+20];      depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];   <span class="comment">% ms</span>
            predict_search(4,:) = [2.5, 2.5+20];  depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [2.5, 2.5+20];  depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];   <span class="comment">% ms</span>
        <span class="keyword">case</span> 6
            predict_search(2,:) = [-2, 18];       depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [1, 21];        depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [0, 20];        depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    <span class="comment">% ms</span>
        <span class="keyword">case</span> 7
            predict_search(2,:) = [-13.5, 20-13.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [-15.5, 20-15.5]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [-20.5, -0.5]; depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];   <span class="comment">% ms</span>
        <span class="keyword">case</span> 8
            predict_search(2,:) = [-20,0];        depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [-9.5,20-9.5];  depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [-9.5,20-9.5];  depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    <span class="comment">% ms</span>
        <span class="keyword">case</span> 9
            predict_search(2,:) = [-53.5,20-53.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [-7,20-7];       depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [-41,20-41];     depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    <span class="comment">% ms</span>
        <span class="keyword">case</span> 10
            predict_search(2,:) = [-69,20-69];     depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(4,:) = [-56,20-56];     depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    <span class="comment">% ms</span>
            predict_search(6,:) = [-61,20-61];      depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    <span class="comment">% ms</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">%readjust</span>

    <span class="comment">% Remember values for later plt</span>
    <span class="keyword">if</span> sub == subject
        predict_search_plt = predict_search;
        depend_search_plt = depend_search;
    <span class="keyword">end</span>

    <span class="comment">% Load data from defined subject defined by loop</span>
    data = total_data{1,1,sub};
    step_index = total_step{1,1,sub};

    <span class="comment">% Find predictor and depended</span>
    <span class="keyword">for</span> k = 1:3
        step = steps_tested(k);

        [rise, fall] = func_find_edge(step);                    <span class="comment">% rise and fall value for the given step</span>
        falling = []; falling = step_index{protocol}(:,fall);   <span class="comment">% fall indexes for all sweeps</span>
        rising  = []; rising  = step_index{protocol}(:,rise);   <span class="comment">% rise indexes for all sweeps</span>

        step_sec{sub}(k,:) = (falling(:) - rising(:))*dt;        <span class="comment">% duration of each step phase, unit [sec]</span>

        <span class="comment">% Re-define window ms to sample</span>
        predict_search_index = floor(ms2sec(predict_search(step,:))*Fs);  <span class="comment">% unit [sample]</span>
        depend_search_index  = floor(ms2sec(depend_search(step,:))*Fs);   <span class="comment">% unit [sample]</span>

        <span class="keyword">for</span> sweep = 1:size(data{protocol,1},1)


            <span class="comment">% Find rise index for the given step and define window</span>
            rise_index = step_index{protocol}(sweep,rise);
            predict_search_array = []; predict_search_array = predict_search_index(1)+rise_index : predict_search_index(2)+rise_index;
            depend_search_array  = []; depend_search_array = depend_search_index(1)+rise_index : depend_search_index(2)+rise_index;


            <span class="comment">% PREDICTOR VALUES:</span>
            ang_data = rescale(data{protocol,ANG}((sweep),:));
            <span class="comment">%predictor_value{sub}(step,sweep) = mean(data{protocol,ANG}((sweep), predict_search_array),2);</span>
            <span class="comment">%predictor_value{sub}(step, sweep) = (data{protocol,ANG}((sweep),predict_search_array(1)) - data{protocol,ANG}((sweep),predict_search_array(end))) / diff(predict_search(step,:));</span>
            <span class="comment">%predictor_value{sub}(step,sweep) =  mean(ang_data(predict_search_array));</span>
            predictor_value{sub}(step,sweep) =  (ang_data(predict_search_array(1)) - ang_data(predict_search_array(end))) / diff(predict_search(step,:));

            <span class="comment">% DEPENDED VALUES</span>
            <span class="keyword">for</span> EMG = [SOL, TA]
                EMG_data = (data{protocol,EMG}((sweep),:));

                step_EMG{sub}(EMG,k,sweep) = mean(EMG_data( [rising(sweep):falling(sweep)] ));  <span class="comment">% EMG activity for the whole standphase</span>
                depended_value{sub}(EMG, step, sweep) =  max(EMG_data(depend_search_array)) - mean(EMG_data(depend_search_array));
                <span class="comment">%depended_value{sub}(sensory_type, step, sweep) = mean(data{protocol,sensory_type}((sweep), depend_search_array),2);</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">%sweep</span>
    <span class="keyword">end</span> <span class="comment">%step</span>
<span class="keyword">end</span>


<span class="keyword">if</span> show_plot
    <span class="keyword">if</span> ~readjust
        msg = <span class="string">"Be Aware: Data re-adjustment is disabled. Manuel defined search-bars applied . . . "</span>;
        fprintf(2,msg);
    <span class="keyword">else</span>
        fprintf(<span class="string">' Data re-adjustment enabled. General search bar applied . . .'</span>)
    <span class="keyword">end</span>

    <span class="comment">% Load data for plot, defined by &gt;&gt; subject &lt;&lt;</span>
    data = total_data{1,1,subject};
    step_index = total_step{1,1,subject};

    <span class="comment">% Plot figure</span>
    fig = findobj(<span class="string">'Name'</span>, <span class="string">'Pre-baseline'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
    figSize = [50 50 width-200 height-200]; <span class="comment">% where to plt and size</span>
    figure(<span class="string">'Name'</span>, <span class="string">'Pre-baseline'</span>,<span class="string">'Position'</span>, figSize); <span class="comment">% begin plot</span>
    sgtitle(<span class="string">"TASK 1.1 Data: Prebaseline. Subject: "</span> + subject + <span class="string">". [n = "</span> + size(data{protocol,1},1) + <span class="string">"]."</span>);

    <span class="comment">% Patch properties</span>
    y_pat = [-1000 -1000 1000 1000];
    patchcolor = <span class="string">"blue"</span>;
    FaceAlpha = 0.4;

    <span class="keyword">for</span> k = 1:3 <span class="comment">% loop through steps</span>
        x_pat_pre = [predict_search_plt(steps_tested(k),1) predict_search_plt(steps_tested(k),2) predict_search_plt(steps_tested(k),2) predict_search_plt(steps_tested(k),1)];
        x_pat_dep = [depend_search_plt(steps_tested(k),1) depend_search_plt(steps_tested(k),2) depend_search_plt(steps_tested(k),2) depend_search_plt(steps_tested(k),1)];

        data_plot = cell(3,7);
        [data_plot{protocol,:}] = func_align(step_index{protocol}, data{protocol,[1:4,6:7]}, <span class="string">'sec_before'</span>, ms2sec(before), <span class="string">'sec_after'</span>, ms2sec(after), <span class="string">'alignStep'</span>, align_with_obtions(k));

        <span class="comment">% Predictor</span>
        sensor_type = [ANG, VEL]; <span class="comment">% Ankle and velocity</span>
        <span class="keyword">for</span> i = 1:numel(sensor_type)
            subplot(4,3,0+k + (i-1)*3); hold <span class="string">on</span>; <span class="comment">% Ankel</span>
            <span class="comment">% Formalia setup</span>
            ylabel(<span class="string">"Position"</span>);
            title(<span class="string">"Step "</span> + k*2)
            subtitle(<span class="string">"Ankel"</span> +<span class="string">" "</span>+ predict_search_plt(steps_tested(k),1) + <span class="string">" : "</span>+predict_search_plt(steps_tested(k),2)+<span class="string">"ms"</span>)
            xlim(xlimits)

            <span class="comment">% Plt data</span>
            y = mean(data_plot{protocol,sensor_type(i)},1);
            std_dev = std(data_plot{protocol,sensor_type(i)});
            curve1 = y + std_dev;
            curve2 = y - std_dev;
            x_axis = data_plot{protocol,time};
            x_axis = sec2ms(x_axis);
            x2 = [x_axis, fliplr(x_axis)];
            inBetween = [curve1, fliplr(curve2)];
            fill(x2, inBetween, [0.75, 0.75, 0.75], <span class="string">'LineStyle'</span>,<span class="string">'none'</span>);
            plot(x_axis, y, <span class="string">'LineWidth'</span>, 2, <span class="string">"color"</span>,<span class="string">"black"</span>);
            YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)]);
            patch(x_pat_pre,y_pat,patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, <span class="string">"none"</span>)
        <span class="keyword">end</span>

        <span class="comment">% Depended</span>
        sensor_type = [SOL, TA]; <span class="comment">% Soleus and Tibialis</span>
        <span class="keyword">for</span> i = 1:numel(sensor_type)
            subplot(4,3, 6+k+(i-1)*3); hold <span class="string">on</span>;
            <span class="comment">% Formalia setup</span>
            ylabel(labels_ms(sensor_type(i)));
            subtitle(labels(sensor_type(i)) +<span class="string">" "</span>+ depend_search_plt(steps_tested(k),1) + <span class="string">" : "</span>+depend_search_plt(steps_tested(k),2)+<span class="string">"ms"</span>)
            xlim(xlimits)

            <span class="comment">% Plt data</span>
            y = mean(data_plot{protocol,sensor_type(i)},1);
            std_dev = std(data_plot{protocol,sensor_type(i)});
            curve1 = y + std_dev;
            curve2 = y - std_dev;
            x_axis = data_plot{protocol,time};
            x_axis = sec2ms(x_axis);
            x2 = [x_axis, fliplr(x_axis)];
            inBetween = [curve1, fliplr(curve2)];
            fill(x2, inBetween, [0.75, 0.75, 0.75], <span class="string">'LineStyle'</span>,<span class="string">'none'</span>);
            plot(x_axis, y, <span class="string">'LineWidth'</span>, 2, <span class="string">"color"</span>,<span class="string">"black"</span>);
            YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)]);
            patch(x_pat_dep,y_pat,patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, <span class="string">"none"</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% Define the file name and path to save the PNG file</span>
    filename = <span class="string">"Subject"</span>+subject+<span class="string">".png"</span>;
    filepath = <span class="string">'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/task1 - control step regresion/non-readjusted and all samples/'</span>;
    fullpath = fullfile(filepath, filename);
    <span class="keyword">if</span> savepgn
        saveas(gcf, fullpath, <span class="string">'png'</span>);
    <span class="keyword">end</span>


<span class="comment">% ====================================</span>

    <span class="comment">% begin plot</span>
    fig = findobj(<span class="string">'Name'</span>, <span class="string">'Pre-baseline2'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
    screensize = get(0,<span class="string">'ScreenSize'</span>);
    figSize = [100 100 width-200 height-200]; <span class="comment">% where to plt and size</span>
    figure(<span class="string">'Position'</span>,figSize,<span class="string">'Name'</span>, <span class="string">'Pre-baseline2'</span>);

    marker = [<span class="string">"*"</span>,<span class="string">"."</span>,<span class="string">"x"</span>];
    sgtitle(<span class="string">"Single subject [sub="</span>+ subject +<span class="string">"]. Weighted: "</span>+weighting_data+<span class="string">". Re-align: "</span> + readjust)

    sensory_type = [SOL, TA];
    <span class="keyword">for</span> i = 1:numel(sensory_type)
        depended = []; predictor = [];
        <span class="keyword">for</span> k = 1:3
            subplot(2,5,k+(i-1)*5 ); hold <span class="string">on</span>
                <span class="keyword">if</span> k == 1; ylabel(labels(sensory_type(i))); <span class="keyword">end</span>
                de = []; de = nonzeros(squeeze(depended_value{subject}(sensory_type(i), steps_tested(k),:)));
                pr = []; pr = nonzeros(squeeze(predictor_value{subject}(steps_tested(k),:)));
                mdl = fitlm(pr, de);
                b = table2array(mdl.Coefficients(1,1));
                a = table2array(mdl.Coefficients(2,1));
                p_value = round(table2array(mdl.Coefficients(2,4)), 3);
                r2 = round(mdl.Rsquared.Adjusted, 3);
                linearReg = @(x) x*a + b;
                plot(pr, de, marker(k), <span class="string">"color"</span>, <span class="string">"blue"</span>)
                plot(pr, linearReg(pr), <span class="string">"color"</span>, <span class="string">"red"</span>)
                <span class="keyword">if</span> p_value &lt; 0.05
                    subtitle([<span class="string">'P-value: {\color{black} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
                <span class="keyword">else</span>
                    subtitle([<span class="string">'P-value: {\color{red} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
                <span class="keyword">end</span>
                title(<span class="string">"Step "</span> + steps_tested(k))

            subplot(2,5,4+5*(i-1):5+5*(i-1)); hold <span class="string">on</span>
                depended(k,:) = nonzeros(squeeze(depended_value{subject}(sensory_type(i), steps_tested(k),:)));
                predictor(k,:) = nonzeros(squeeze(predictor_value{subject}(steps_tested(k),:)));
                plot(predictor(k,:), depended(k,:), marker(k), <span class="string">"color"</span>, <span class="string">"blue"</span>)
        <span class="keyword">end</span>

        <span class="comment">% Linear regression</span>
        depended_all_step = [depended(1,:) depended(2,:) depended(3,:)];
        predictor_all_step = [predictor(1,:) predictor(2,:) predictor(3,:)];
        mdl = fitlm(predictor_all_step, depended_all_step);
        b = table2array(mdl.Coefficients(1,1));
        a = table2array(mdl.Coefficients(2,1));
        p_value =  table2array(mdl.Coefficients(2,4));
        r2 = round(mdl.Rsquared.Adjusted, 3);
        linearReg = @(x) x*a + b;
        plot(predictor_all_step, linearReg(predictor_all_step), <span class="string">"color"</span>, <span class="string">"red"</span>)
        title(<span class="string">"All Step "</span>)


        <span class="comment">% Plt formalia</span>
        legend([<span class="string">"Data: Step 2"</span>, <span class="string">"Data: Step 4"</span>, <span class="string">"Data: Step 6"</span>,<span class="string">"Fit"</span>])
        <span class="keyword">if</span> p_value &lt; 0.05
            subtitle([<span class="string">'P-value: {\color{black} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
        <span class="keyword">else</span>
            subtitle([<span class="string">'P-value: {\color{red} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Set y-limits and x-limits on all subplots</span>
    ax = findobj(gcf, <span class="string">'type'</span>, <span class="string">'axes'</span>);
    ylims = get(ax, <span class="string">'YLim'</span>);
    xlims = get(ax, <span class="string">'XLim'</span>);
    [~, idx_y_ta]  = max(cellfun(@(x) diff(x), ylims(1:4)));
    [~, idx_y_sol] = max(cellfun(@(x) diff(x), ylims(5:8)));
    [~, idx_x_ta]  = max(cellfun(@(x) diff(x), xlims(1:4)));
    [~, idx_x_sol] = max(cellfun(@(x) diff(x), xlims(5:8)));
    idx_y_sol = idx_y_sol+4;
    idx_x_sol = idx_x_sol+4;
    <span class="keyword">for</span> i = 1:numel(ax)
        <span class="keyword">if</span> any(i == 1:4)
            set(ax(i), <span class="string">'YLim'</span>, ylims{idx_y_ta})
            set(ax(i), <span class="string">'XLim'</span>, xlims{idx_x_ta})
        <span class="keyword">elseif</span> any(i == 5:8)
            set(ax(i), <span class="string">'YLim'</span>, ylims{idx_y_sol})
            set(ax(i), <span class="string">'XLim'</span>, xlims{idx_x_sol})
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Save as PNG</span>
    filename = <span class="string">"All steps. Subject"</span>+subject+<span class="string">".png"</span>;
    <span class="comment">% filepath = 'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/task1 - control step regresion/readjusted and all samples/';</span>
    fullpath = fullfile(filepath, filename);
    <span class="keyword">if</span> savepgn; saveas(gcf, fullpath, <span class="string">'png'</span>); <span class="keyword">end</span>

    fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">
script: TASK 1.1  . . . disable 
</pre><h2 id="15">Task 1.2 FC correlation with EMG (Assemble steps)</h2><pre class="codeinput">fprintf(<span class="string">'script: TASK 1.2  . . . '</span>); tic
show_plot = false;

<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
<span class="keyword">if</span> show_plot
    reg_data = struct;
    marker = [<span class="string">"*"</span>,<span class="string">"."</span>,<span class="string">"x"</span>];

    <span class="comment">% Re-arrange data from cell to struct.</span>
    data_reg = struct;
    data_reg.dep_steps = cell(2,3);     <span class="comment">% depended sortet each step,  [sol,ta]</span>
    data_reg.pre_steps = cell(1,3);     <span class="comment">% predictor sortet each step, [vel]</span>
    data_reg.pre = [];                  <span class="comment">% depended sortet all step,   [sol,ta]</span>
    data_reg.dep = cell(2,1);           <span class="comment">% predictor sortet all step,  [vel]</span>

    <span class="comment">% Re-arrange data from cell to array and save in struct</span>
    <span class="keyword">for</span> sub = inc_sub
        <span class="keyword">for</span> step = 1:3
            <span class="keyword">for</span> EMG = [SOL,TA]
                data_reg.dep_steps{EMG,step} = [data_reg.dep_steps{EMG,step}, nonzeros(squeeze(depended_value{sub}(EMG, steps_tested(step),:)))' ];
                data_reg.dep{EMG} = [data_reg.dep{EMG}, nonzeros(squeeze(depended_value{sub}(EMG, steps_tested(step),:)))' ];
            <span class="keyword">end</span>
            data_reg.pre = [data_reg.pre,  nonzeros(squeeze(predictor_value{sub}(steps_tested(step),:)))'];
            data_reg.pre_steps{step} = [data_reg.pre_steps{step}, nonzeros(squeeze(predictor_value{sub}(steps_tested(step),:)))'];
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Defining plt window size</span>
    figSize = [100 100 width-200 height-200]; <span class="comment">% where to plt and size</span>
    fig = findobj(<span class="string">'Name'</span>, <span class="string">'Pre-baseline all subject'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
    figure(<span class="string">'Name'</span>,<span class="string">'Pre-baseline all subject'</span>,<span class="string">'Position'</span>, figSize); <span class="comment">% begin plot</span>
    sgtitle(<span class="string">"Correlation [n="</span>+numel(inc_sub)+<span class="string">"]. Weighted: "</span>+weighting_data+<span class="string">". Re-align: "</span> + readjust)


    <span class="comment">% Plot subject data in different colors</span>
    <span class="keyword">for</span> sub = inc_sub <span class="comment">% subject</span>
        <span class="keyword">for</span> sensory_type = [SOL,TA] <span class="comment">% muscle type</span>
            depended = []; predictor = [];
            <span class="keyword">for</span> k = 1:3 <span class="comment">% loop steps</span>
                depended(k,:) = nonzeros(squeeze(depended_value{sub}(sensory_type, steps_tested(k),:)));
                predictor(k,:) = nonzeros(squeeze(predictor_value{sub}(steps_tested(k),:)));

                <span class="comment">% Remember p-value and slope for later plot</span>
                mdl = fitlm(predictor(k,:), depended(k,:));
                reg_data.slopes(sub, sensory_type, k) = table2array(mdl.Coefficients(2,1));   <span class="comment">% slopes</span>
                reg_data.p_value(sub, sensory_type, k) = table2array(mdl.Coefficients(2,4));  <span class="comment">% p_values</span>

                <span class="comment">% Plt the individuel steps</span>
                subplot(2, 5, 5*(sensory_type-1)+k); hold <span class="string">on</span>; <span class="comment">% 5*(s-1)+k={1,2,3,6,7,8}, k={1,2,3}, s={1,2}</span>
                plot(predictor(k,:), depended(k,:),<span class="string">'x'</span>);
                title(<span class="string">"Step "</span> + steps_tested(k))
                xlabel(<span class="string">"Pos(s-e)/w"</span>)
                ylabel(labels(sensory_type))
            <span class="keyword">end</span>

            <span class="comment">% Plt the combined steps</span>
            subplot(2,5, 4+5*(sensory_type-1):5+5*(sensory_type-1)); hold <span class="string">on</span> <span class="comment">% 4+5*(s-1)={4,9}, 5+5*(s-1)={5,10} s={1,2}</span>
            plot(predictor(:)', depended(:)',<span class="string">'x'</span>)
            title(<span class="string">"All steps"</span>)
            ylabel(labels(sensory_type))
            xlabel(<span class="string">"Pos(s-e)/w"</span>)

            <span class="comment">% Remember p-value and slope for later plot</span>
            mdl = fitlm(predictor(:), depended(:));
            reg_data.slopes(sub, sensory_type, 4)  = table2array(mdl.Coefficients(2,1));  <span class="comment">% slopes</span>
            reg_data.p_value(sub, sensory_type, 4) = table2array(mdl.Coefficients(2,4));  <span class="comment">% p_values</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Set y-limits and x-limits on all subplots</span>
    ax = findobj(gcf, <span class="string">'type'</span>, <span class="string">'axes'</span>);
    ylims = get(ax, <span class="string">'YLim'</span>);
    xlims = get(ax, <span class="string">'XLim'</span>);
    [~, idx_y_ta]  = max(cellfun(@(x) diff(x), ylims(1:4)));
    [~, idx_y_sol] = max(cellfun(@(x) diff(x), ylims(5:8)));
    [~, idx_x_ta]  = max(cellfun(@(x) diff(x), xlims(1:4)));
    [~, idx_x_sol] = max(cellfun(@(x) diff(x), xlims(5:8)));
    idx_y_sol = idx_y_sol+4;
    idx_x_sol = idx_x_sol+4;
    <span class="keyword">for</span> i = 1:numel(ax)
        <span class="keyword">if</span> any(i == 1:4)
            set(ax(i), <span class="string">'YLim'</span>, ylims{idx_y_ta})
            set(ax(i), <span class="string">'XLim'</span>, xlims{idx_x_ta})
        <span class="keyword">elseif</span> any(i == 5:8)
            set(ax(i), <span class="string">'YLim'</span>, ylims{idx_y_sol})
            set(ax(i), <span class="string">'XLim'</span>, xlims{idx_x_sol})
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Plot regression</span>
    <span class="keyword">for</span> sensory_type = [SOL,TA] <span class="comment">% loop</span>
        <span class="keyword">for</span> step = 1:3 <span class="comment">% loop steps</span>
            mdl = fitlm(data_reg.pre_steps{step}, data_reg.dep_steps{sensory_type, step});
            b = table2array(mdl.Coefficients(1,1));
            a = table2array(mdl.Coefficients(2,1));
            p_value = table2array(mdl.Coefficients(2,4));
            r2 = round(mdl.Rsquared.Adjusted,3);
            linearReg = @(x) x*a + b;
            subplot(2, 5, 5*(sensory_type-1)+step); hold <span class="string">on</span>;
            plot(data_reg.pre_steps{step}, linearReg(data_reg.pre_steps{step}), <span class="string">"color"</span>, <span class="string">"red"</span>)
            <span class="keyword">if</span> p_value &lt; 0.05
                subtitle([<span class="string">'P-value: {\color{black} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
            <span class="keyword">else</span>
                subtitle([<span class="string">'P-value: {\color{red} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        mdl = fitlm(data_reg.pre, data_reg.dep{sensory_type});
        b = table2array(mdl.Coefficients(1,1));
        a = table2array(mdl.Coefficients(2,1));
        p_value = table2array(mdl.Coefficients(2,4));
        r2 = round(mdl.Rsquared.Adjusted,3);
        linearReg = @(x) x*a + b;
        subplot(2,5, 4+5*(sensory_type-1):5+5*(sensory_type-1)); hold <span class="string">on</span>
        plot(data_reg.pre_steps{step}, linearReg(data_reg.pre_steps{step}), <span class="string">"color"</span>, <span class="string">"red"</span>)
        <span class="keyword">if</span> p_value &lt; 0.05
            subtitle([<span class="string">'P-value: {\color{black} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
        <span class="keyword">else</span>
            subtitle([<span class="string">'P-value: {\color{red} '</span> num2str(p_value) <span class="string">'}. R^2'</span> num2str(r2)])
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Save as PNG</span>
    filename = <span class="string">"All subject (1-"</span>+numel(names)+<span class="string">").png"</span>;
    fullpath = fullfile(filepath, filename);
    <span class="keyword">if</span> savepgn; saveas(gcf, fullpath, <span class="string">'png'</span>); <span class="keyword">end</span>

    fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: TASK 1.2  . . . disable 
</pre><h2 id="16">Task 1.3 FC correlation with EMG (slopes)</h2><p>Find the best parameters for one subject and apply them to the other    subjects. one factor anova</p><pre class="codeinput">pltShow = false;
savepgn = false;


<span class="keyword">if</span> pltShow
    <span class="keyword">if</span> exist(<span class="string">"reg_data"</span>)
        figSize = [300 250 700 400]; <span class="comment">% where to plt and size</span>

        <span class="comment">% Check if a figure with the name 'TASK3' is open</span>
        fig = findobj(<span class="string">'Name'</span>, <span class="string">'slopes'</span>);
        <span class="comment">% If a figure is found, close it</span>
        <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>

        figure(<span class="string">'name'</span>,<span class="string">'slopes'</span>,<span class="string">'Position'</span>, figSize); <span class="comment">% begin plot</span>
        hold <span class="string">on</span>
        sgtitle(<span class="string">"Correlations slopes [sub="</span>+numel(inc_sub)+<span class="string">"]. Weighted: "</span>+weighting_data+<span class="string">". Re-align: "</span> + readjust)

        <span class="keyword">for</span> sensory_type = [SOL, TA]
            <span class="keyword">for</span> step = 1:4
                <span class="keyword">if</span> step == 4
                    subplot(1,5,4:5); hold <span class="string">on</span>
                    title(<span class="string">"All steps"</span>)
                <span class="keyword">else</span>
                    subplot(1,5,step); hold <span class="string">on</span>
                    title(<span class="string">"Step "</span> + step)
                <span class="keyword">end</span>
                slopes  = reg_data.slopes(inc_sub, sensory_type, step);
                p_value = reg_data.p_value(inc_sub,sensory_type, step);
                x_value = ones(1,size(slopes,1));
                <span class="keyword">if</span> sensory_type == TA; x_value=x_value+1; <span class="keyword">end</span>

                plot([0 3],[0 0], <span class="string">'color'</span>, <span class="string">'black'</span>)
                plot(x_value(1), mean(slopes), <span class="string">"_"</span>, <span class="string">'Color'</span>, <span class="string">'red'</span>, <span class="string">'linewidth'</span>, 4)
                plot(x_value, slopes, <span class="string">'.'</span>, <span class="string">'color'</span>, <span class="string">'black'</span>) <span class="comment">% soleus data indiv</span>
                <span class="keyword">for</span> i = 1:length(p_value)
                    <span class="keyword">if</span> p_value(i) &lt; 0.05
                        plot(x_value, slopes(i), <span class="string">'o'</span>, <span class="string">'linewidth'</span>,2, <span class="string">'color'</span>, [0.75,0.75,0.75]) <span class="comment">% soleus data indiv</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                xticks([1 2]);
                xticklabels({<span class="string">'SOL'</span>, <span class="string">'TA'</span>});
                grid <span class="string">on</span>;

                <span class="keyword">if</span> step == 1
                    ylabel(<span class="string">"Regression Slopes"</span>+newline+<span class="string">" [ \alpha ]"</span>)
                <span class="keyword">elseif</span> step == 4
                    legend([<span class="string">""</span>, <span class="string">"Group mean"</span>, <span class="string">"Slope (subject)"</span>, <span class="string">"&lt; 0.05"</span>])
                <span class="keyword">end</span>

            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Set y-limits on all subplots</span>
        ax = findobj(gcf, <span class="string">'type'</span>, <span class="string">'axes'</span>);
        ylims = get(ax, <span class="string">'YLim'</span>);
        max_value = max(cellfun(@max, ylims));
        min_value = min(cellfun(@min, ylims));
        <span class="keyword">for</span> i = 1:numel(ax)
            set(ax(i), <span class="string">'YLim'</span>, ([min_value max_value]))
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        msg = <span class="string">"\n     Need to run 'Task 1.2' before to enable this section to plot \n"</span>;
        fprintf(2,msg);
    <span class="keyword">end</span>
    a = num2str(weighting_data) ;
    b = num2str(readjust);

    filename = [<span class="string">'Correlations slopes [sub='</span> num2str(numel(inc_sub)) <span class="string">']. Weighted '</span> num2str(weighting_data) <span class="string">' . Re-align '</span> num2str(readjust) <span class="string">'.png'</span>];
    filepath = <span class="string">'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/task1 - control step regresion/slopes/'</span>;
    fullpath = fullfile(filepath, filename);
    <span class="keyword">if</span> savepgn; saveas(gcf, fullpath, <span class="string">'png'</span>); <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="17">Speed vs EMG</h2><pre class="codeinput">fprintf(<span class="string">'script: TASK 1.4 Speed  . . . '</span>); tic

show_plot_speed = true;
EMG_compl_step = true;

<span class="comment">%   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .</span>

<span class="comment">% step_ms{sub}(k,:) = (falling(:) - rising(:))*dt;        % duration of each step phase, unit [sec]</span>
<span class="comment">% step_EMG{sub}(EMG,k,sweep) = mean(EMG_data( [rising(sweep):falling(sweep)] ));  % EMG activity for the whole standphase</span>
<span class="comment">% depended_value{sub}(EMG, step, sweep) =  max(EMG_data(depend_search_array)) - mean(EMG_data(depend_search_array));</span>

<span class="keyword">if</span> show_plot_speed

    <span class="comment">% Re-arrange data from cell to struct.</span>
    speed_reg = struct;
    speed_reg.pre_steps = cell(1,3);     <span class="comment">% predictor sortet each step, [time]</span>
    speed_reg.pre = [];                  <span class="comment">% predictor sortet all step,  [time]</span>
    speed_reg.dep = cell(2,1);           <span class="comment">% depended sortet all step,   [sol,ta]</span>
    speed_reg.dep_steps = cell(2,3);     <span class="comment">% depended sortet each step,  [sol,ta]</span>

    <span class="comment">% Re-arrange data from cell to array and save in struct</span>
    <span class="keyword">for</span> sub = inc_sub
        <span class="keyword">for</span> s = 1:3
            EMG = [SOL,TA];
            <span class="keyword">for</span> e = 1:numel(EMG)
                <span class="keyword">if</span> EMG_compl_step == true
                    step = steps_tested(s);
                    speed_reg.dep_steps{e,s} = [speed_reg.dep_steps{e,s}, squeeze(step_EMG{sub}(EMG(e),s,:))' ];
                    speed_reg.dep{e}         = [speed_reg.dep{e}        , squeeze(step_EMG{sub}(EMG(e),s,:))' ];
                <span class="keyword">else</span>
                    data_reg.dep_steps{e,s} = [data_reg.dep_steps{e,s}, squeeze(depended_value{sub}(EMG(e),step,:))' ];
                    data_reg.dep{e}         = [data_reg.dep{e}        , squeeze(depended_value{sub}(EMG(e),step,:))' ];
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            speed_reg.pre          = [speed_reg.pre         , squeeze(step_EMG{sub}(EMG(e),s,:))];
            speed_reg.pre_steps{s} = [speed_reg.pre_steps{s}, squeeze(step_EMG{sub}(EMG(e),s,:))'];
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="comment">% Begin plot</span>
    fig = findobj(<span class="string">'Name'</span>, <span class="string">'Speed'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
    figure(<span class="string">'name'</span>,<span class="string">'Speed'</span>); <span class="comment">% begin plot</span>

    <span class="keyword">for</span> sub = inc_sub  <span class="comment">% subject</span>
        EMG = [SOL, TA];
        <span class="keyword">for</span> e = 1:numel(EMG)
            <span class="keyword">for</span> k = 1:3
                step = steps_tested(k);
                x = []; y = []; <span class="comment">% Clear the variable</span>

                x = squeeze(step_sec{sub}(k,:));
                <span class="keyword">if</span> EMG_compl_step == true
                    y = squeeze(step_EMG{sub}(EMG(e),k,:));
                <span class="keyword">else</span>
                    y = squeeze(depended_value{sub}(EMG(e),step,:));
                <span class="keyword">end</span>

                subplot(2,5,k+(e-1)*5);  hold <span class="string">on</span>
                <span class="keyword">if</span> k == 1; ylabel(labels(EMG(e))); <span class="keyword">end</span>
                plot(x,y,<span class="string">'x'</span>)

            <span class="keyword">end</span> <span class="comment">%step</span>
            x_all = []; y_all = [];
            x_all = squeeze(step_sec{sub}(1:3,:));
            <span class="keyword">if</span> EMG_compl_step == true
                y_all = []; y_all = squeeze(step_EMG{sub}(EMG(e),1:3,:));
            <span class="keyword">else</span>
                y_all = []; y_all = squeeze(depended_value{sub}(EMG(e),[2,4,6],:));
            <span class="keyword">end</span>

            subplot(2,5,4+(e-1)*5:5+(e-1)*5); hold <span class="string">on</span>;
            plot(x_all(:) , y_all(:), <span class="string">'x'</span>)
        <span class="keyword">end</span> <span class="comment">%emg</span>
    <span class="keyword">end</span> <span class="comment">%sub</span>




     <span class="comment">% Set y-limits and x-limits on all subplots</span>
    ax = findobj(gcf, <span class="string">'type'</span>, <span class="string">'axes'</span>);
    ylims = get(ax, <span class="string">'YLim'</span>);
    xlims = get(ax, <span class="string">'XLim'</span>);
    [~, idx_y_ta]  = max(cellfun(@(x) diff(x), ylims(1:4)));
    [~, idx_y_sol] = max(cellfun(@(x) diff(x), ylims(5:8)));
    [~, idx_x_ta]  = max(cellfun(@(x) diff(x), xlims(1:4)));
    [~, idx_x_sol] = max(cellfun(@(x) diff(x), xlims(5:8)));
    idx_y_sol = idx_y_sol+4;
    idx_x_sol = idx_x_sol+4;
    <span class="keyword">for</span> i = 1:numel(ax)
        <span class="keyword">if</span> any(i == 1:4)
            set(ax(i), <span class="string">'YLim'</span>, ylims{idx_y_ta})
            set(ax(i), <span class="string">'XLim'</span>, xlims{idx_x_ta})
        <span class="keyword">elseif</span> any(i == 5:8)
            set(ax(i), <span class="string">'YLim'</span>, ylims{idx_y_sol})
            set(ax(i), <span class="string">'XLim'</span>, xlims{idx_x_sol})
        <span class="keyword">end</span>
    <span class="keyword">end</span>


            fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
        <span class="keyword">else</span>
    fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>

2+2
</pre><pre class="codeoutput">script: TASK 1.4 Speed  . . . done [ 1.16 sec ] 

ans =

     4

</pre><img vspace="5" hspace="5" src="All_hor_01.png" alt=""> <h2 id="18">Task 2.1 Within step adjustment of EMG acticity due to natural angle variation. (Single subject)</h2><p>Find whether the EMG activity is passively adjusted to changes in angle    trajectories. All steps and seperated step nassarro two plot: inden burst activitet og til max burst activitet (all subject)</p><pre class="codeinput">fprintf(<span class="string">'script: TASK 2.1  . . . '</span>); tic

show_plot = false;
subject = 2; <span class="comment">%</span>
protocol = CTL;
before = 100; <span class="comment">% [ms]</span>
after = 0; <span class="comment">% [ms]</span>

pre = 1; search_area(pre,:) = [0.15; 0.60]; <span class="comment">% predictor search window</span>
dep = 2; search_area(dep,:) = [0.15; 0.70]; <span class="comment">% depended search window</span>

<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
<span class="comment">% Load data from subject</span>
data = total_data{1,1,subject};
step_index = total_step{1,1,subject};

<span class="keyword">if</span> show_plot
    figSize = [200 60 1000 700];
    figure(<span class="string">'Position'</span>, figSize)
    sgtitle(<span class="string">"Within step modulation due to natural angle variation. Subject "</span>+ subject + newline + <span class="string">"{\color{blue}Graph} larger than avg. and {\color{red}Graph} less than avg."</span>)

    clear <span class="string">win_avg_ang</span> <span class="string">win_avg_sol</span> <span class="string">win_avg_ta</span>
    <span class="keyword">for</span> step = 1:3
        <span class="comment">% Align data needed to be plotted</span>
        clear <span class="string">temp_plot</span>
        temp_plot = cell(3,7);
        [temp_plot{protocol,:}] = func_align(step_index{protocol}, data{proto,[1:4,6:7]}, <span class="string">'sec_before'</span>, ms2sec(before), <span class="string">'sec_after'</span>, ms2sec(after), <span class="string">'alignStep'</span>, align_with_obtions(step));
        x_axis = temp_plot{protocol, time};

        <span class="comment">% Align data needed to calculate window avg</span>
        clear <span class="string">temp_data</span>
        temp_data = cell(3,7);
        [temp_data{protocol,:}] = func_align(step_index{protocol}, data{proto,[1:4,6:7]}, <span class="string">'alignStep'</span>, align_with_obtions(step));

        <span class="comment">% Defined window</span>
        <span class="keyword">for</span> cc = [dep, pre]
            pct_start_index(cc) = ceil(size(temp_data{protocol,time},2)*search_area(cc,1));   <span class="comment">% window begin in idx</span>
            pct_end_index(cc)   = ceil(size(temp_data{protocol,time},2)*search_area(cc,2));   <span class="comment">% window end in idx</span>
            pct_start_sec(cc) = temp_data{protocol,time}(1,pct_start_index(cc));              <span class="comment">% window begin in sec</span>
            pct_end_sec(cc)   = temp_data{protocol,time}(1,pct_end_index(cc));                <span class="comment">% window end in sec</span>
        <span class="keyword">end</span>

        <span class="comment">% Calculate average in window</span>
        win_avg_ang(step,:) = mean(temp_data{protocol,ANG}(:,pct_start_index(pre) : pct_end_index(pre)),2); <span class="comment">% mean value of sweeps window</span>
        win_avg_sol(step,:) = mean(temp_data{protocol,SOL}(:,pct_start_index(dep):pct_end_index(dep)),2);   <span class="comment">% mean value of sweeps window</span>
        win_avg_ta(step,:) = mean(temp_data{protocol,TA}(:,pct_start_index(dep):pct_end_index(dep)),2);     <span class="comment">% mean value of sweeps window</span>

        <span class="comment">% Sort data according</span>
        [win_avg_ang(step,:), win_avg_idx] = sort(win_avg_ang(step,:), <span class="string">'ascend'</span>); <span class="comment">% sorts elements in ascending order.</span>
        win_avg_sol(step,:) = win_avg_sol(step, win_avg_idx); <span class="comment">% sort these with found order</span>
        win_avg_ta(step,:) = win_avg_ta(step, win_avg_idx);   <span class="comment">% sort these with found order</span>

        clear <span class="string">lower_index</span> <span class="string">mean_index</span> <span class="string">upper_index</span>
        <span class="comment">% Sort data in groups [low, mid, up]</span>
        dim = size(win_avg_ang,2); <span class="comment">% num of sweeps</span>
        lower_index(:) = 1:floor(dim/3);
        mean_index(:) = floor(dim/3)+1:dim-floor(dim/3);
        upper_index(:) = dim-floor(dim/3)+1:dim;

        <span class="comment">% Mean plot properties</span>
        color_mean = [150 152 158]/255;
        LineWidth_mean = 2;

        <span class="comment">% Upper and lower plot properties</span>
        color_upper = <span class="string">"blue"</span>;
        color_lower = <span class="string">"red"</span>;
        upper_style = <span class="string">"--"</span>;
        lower_style = <span class="string">"-."</span>;
        LineWidth_UL = 1;

        <span class="comment">% Patch properties</span>
        y_pat = [-1000 -1000 2000 2000];
        patchcolor = [251 244 199]/255;
        FaceAlpha = 1;
        EdgeColor = [37 137 70]/255;
        lineWidth_patch = 2;
        <span class="keyword">for</span> cc = [dep, pre]
            x_pat(cc,:) = [pct_start_sec(cc), pct_end_sec(cc), pct_end_sec(cc), pct_start_sec(cc)];
        <span class="keyword">end</span>

        <span class="comment">% Plot figures</span>
        <span class="comment">% ankel</span>
        subplot(330+step); hold <span class="string">on</span>;
        title(<span class="string">"Step "</span> + steps_tested(step))
        subtitle(<span class="string">"Ankel"</span>);
        ylabel(labels_sec(ANG))
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(mean_index),:),1), <span class="string">'LineWidth'</span>, LineWidth_mean, <span class="string">"color"</span>, color_mean)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(upper_index),:),1), upper_style, <span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_upper)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(lower_index),:),1), lower_style,<span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_lower)
            YL = get(gca, <span class="string">'YLim'</span>);
            ylim([YL(1) YL(2)]);
            patch(x_pat(pre,:),y_pat,patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, EdgeColor, <span class="string">'LineWidth'</span>, lineWidth_patch)
            set(gca, <span class="string">'Layer'</span>, <span class="string">'top'</span>)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(mean_index),:),1), <span class="string">'LineWidth'</span>, LineWidth_mean, <span class="string">"color"</span>, color_mean)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(upper_index),:),1), upper_style, <span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_upper)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(lower_index),:),1), lower_style,<span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_lower)


        <span class="comment">% Soleus</span>
        subplot(333+step); hold <span class="string">on</span>;
        subtitle(labels(SOL))
        ylabel(<span class="string">"Soleus"</span>+newline+<span class="string">"[normalized]"</span>)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(mean_index),:),1), <span class="string">'LineWidth'</span>, LineWidth_mean, <span class="string">"color"</span>, color_mean)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(upper_index),:),1), upper_style, <span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_upper)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(lower_index),:),1), lower_style,<span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_lower)
            YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)]);
            patch(x_pat(dep,:),y_pat,patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, EdgeColor, <span class="string">'LineWidth'</span>, lineWidth_patch)
            set(gca, <span class="string">'Layer'</span>, <span class="string">'top'</span>)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(mean_index),:),1), <span class="string">'LineWidth'</span>, LineWidth_mean, <span class="string">"color"</span>, color_mean)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(upper_index),:),1), upper_style, <span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_upper)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(lower_index),:),1), lower_style,<span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_lower)

        <span class="comment">% Tibialis</span>
        subplot(336+step); hold <span class="string">on</span>;
        subtitle(labels(TA))
        ylabel(<span class="string">"Tibialis"</span>+newline+<span class="string">"[normalized]"</span>)
        xlabel(labels_sec(time))
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(mean_index),:),1), <span class="string">'LineWidth'</span>, LineWidth_mean, <span class="string">"color"</span>, color_mean)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(upper_index),:),1), upper_style, <span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_upper)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(lower_index),:),1), lower_style,<span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_lower)
            YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)]);
            patch(x_pat(dep,:),y_pat,patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, EdgeColor, <span class="string">'LineWidth'</span>, lineWidth_patch)
            set(gca, <span class="string">'Layer'</span>, <span class="string">'top'</span>)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(mean_index),:),1), <span class="string">'LineWidth'</span>, LineWidth_mean, <span class="string">"color"</span>, color_mean)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(upper_index),:),1), upper_style, <span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_upper)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(lower_index),:),1), lower_style, <span class="string">'LineWidth'</span>, LineWidth_UL, <span class="string">"color"</span>, color_lower)
    <span class="keyword">end</span>
fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: TASK 2.1  . . . disable 
</pre><h2 id="19">Task 2.2 Within step adjustment of EMG acticity due to natural angle variation. (Single subject)</h2><pre class="codeinput">fprintf(<span class="string">'script: TASK 2.2  . . . '</span>); tic

show_plt = false;

<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
<span class="keyword">if</span> show_plt
    clear <span class="string">x_sol</span> <span class="string">x_ta</span>
    <span class="comment">% Rearrange data to box plot data</span>
    step2 = 1; step4 = 2; step6 = 3;
    <span class="comment">% soleus</span>
    group_low_sol = [win_avg_sol(step2,lower_index) ; win_avg_sol(step4,lower_index) ; win_avg_sol(step6,lower_index)]';
    group_mid_sol = [win_avg_sol(step2,mean_index) ; win_avg_sol(step4,mean_index) ; win_avg_sol(step6,mean_index)]';
    group_up_sol = [win_avg_sol(step2,upper_index) ; win_avg_sol(step4,upper_index) ; win_avg_sol(step6,upper_index)]';
    x_sol = {group_low_sol, group_mid_sol, group_up_sol};
    <span class="comment">% tibialis</span>
    group_low_ta = [win_avg_ta(step2,lower_index) ; win_avg_ta(step4,lower_index) ; win_avg_ta(step6,lower_index)]';
    group_mid_ta = [win_avg_ta(step2,mean_index) ; win_avg_ta(step4,mean_index) ; win_avg_ta(step6,mean_index)]';
    group_up_ta = [win_avg_ta(step2,upper_index) ; win_avg_ta(step4,upper_index) ; win_avg_ta(step6,upper_index)]';
    x_ta = {group_low_ta, group_mid_ta, group_up_ta};

    <span class="comment">% Plot data to get natural y limits</span>
    figure(13);
    boxplotGroup(x_sol);
    YL_sol = get(gca, <span class="string">'YLim'</span>);
    close <span class="string">13</span>

    figure(13);
    boxplotGroup(x_ta);
    YL_ta = get(gca, <span class="string">'YLim'</span>);
    close <span class="string">13</span>

    <span class="comment">% Pl</span>
    <span class="comment">% ot boxplot for single subject</span>
    figure; hold <span class="string">on</span>;
        blue = 	[0 0 1]; red = [1 0 0]; gray = color_mean;

    subplot(211)
        grpLabels = {<span class="string">'Step 2'</span>, <span class="string">'Step 4'</span>, <span class="string">'Step 6'</span>};
        sublabels = {<span class="string">'low'</span>, <span class="string">'mid'</span>, <span class="string">'up'</span>};
        boxplotGroup(x_sol,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels, <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true, <span class="string">'Colors'</span>,[red; gray; blue],<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        ylim([YL_sol(1) YL_sol(2)])
        ylabel(<span class="string">"Normalized muscle activity"</span>+newline+<span class="string">"Soleus"</span>)


    <span class="comment">% Plot boxplot for single subject</span>
    subplot(212);hold <span class="string">on</span>;
        title(<span class="string">"Within step adjustment of EMG acticity due to natural angle variation"</span>,<span class="string">'FontName'</span>,<span class="string">'FixedWidth'</span>)
        subtitle(<span class="string">"Single Subject. Num: "</span> + subject ,<span class="string">'FontName'</span>,<span class="string">'FixedWidth'</span>)
        boxplotGroup(x_ta,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels, <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true, <span class="string">'Colors'</span>,[red; gray; blue],<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        ylim([YL_ta(1) YL_ta(2)])
        ylabel(<span class="string">"Normalized muscle activity"</span>+newline+<span class="string">"Tibialis"</span>)

fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: TASK 2.2  . . . disable 
</pre><h2 id="20">Task 2.3 Within step adjustment of EMG acticity due to natural angle variation. (All subject)</h2><pre class="codeinput">fprintf(<span class="string">'script: TASK 2.3  . . . '</span>); tic
show_plt = false;

<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>
low = 1; mid = 2; up = 3;
step2 = 1; step4 = 2; step6 = 3;

<span class="keyword">if</span> show_plt
    <span class="keyword">for</span> sub = 1:numel(names) <span class="comment">% loop through names</span>
        <span class="keyword">for</span> step = 1:3 <span class="comment">% loop through steps</span>
            <span class="comment">% align data to find window avg</span>
            clear <span class="string">data</span> <span class="string">step_index</span>
            data = total_data{1,1,sub};
            step_index = total_step{1,1,sub};

            clear <span class="string">temp_data</span>
            temp_data = cell(3,7);
            [temp_data{protocol,:}] = func_align(step_index{protocol}, data{proto,[1:4,6:7]}, <span class="string">'alignStep'</span>, align_with_obtions(step));

            <span class="comment">% Defined window</span>
            <span class="keyword">for</span> cc = [dep, pre]
                pct_start_index(cc) = ceil(size(temp_data{protocol,time},2)*search_area(cc,1));   <span class="comment">% window begin in idx</span>
                pct_end_index(cc)   = ceil(size(temp_data{protocol,time},2)*search_area(cc,2));   <span class="comment">% window end in idx</span>
                pct_start_sec(cc) = temp_data{protocol,time}(1,pct_start_index(cc));              <span class="comment">% window begin in sec</span>
                pct_end_sec(cc)   = temp_data{protocol,time}(1,pct_end_index(cc));                <span class="comment">% window end in sec</span>
            <span class="keyword">end</span>

            clear <span class="string">win_avg_ang</span> <span class="string">win_avg_sol</span> <span class="string">win_avg_ta</span>
            <span class="comment">% Calculate average in window</span>
            win_avg_ang(step,:) = mean(temp_data{protocol,ANG}(:,pct_start_index(pre) : pct_end_index(pre)),2); <span class="comment">% mean value of sweeps window</span>
            win_avg_sol(step,:) = mean(temp_data{protocol,SOL}(:,pct_start_index(dep):pct_end_index(dep)),2);   <span class="comment">% mean value of sweeps window</span>
            win_avg_ta(step,:) = mean(temp_data{protocol,TA}(:,pct_start_index(dep):pct_end_index(dep)),2);     <span class="comment">% mean value of sweeps window</span>

             <span class="comment">% Sort data according</span>
            [win_avg_ang(step,:), win_avg_idx] = sort(win_avg_ang(step,:), <span class="string">'ascend'</span>); <span class="comment">% sorts elements in ascending order.</span>
            win_avg_sol(step,:) = win_avg_sol(step, win_avg_idx); <span class="comment">% sort these with found order</span>
            win_avg_ta(step,:) = win_avg_ta(step, win_avg_idx);   <span class="comment">% sort these with found order</span>

            clear <span class="string">lower_index</span> <span class="string">mean_index</span> <span class="string">upper_index</span>
            <span class="comment">% Sort data in groups [low, mid, up]</span>
            dim = size(win_avg_ang,2); <span class="comment">% num of sweeps</span>
            lower_index(:) = 1:floor(dim/3);
            mean_index(:) = floor(dim/3)+1:dim-floor(dim/3);
            upper_index(:) = dim-floor(dim/3)+1:dim;

            <span class="comment">% Subject mean of each subgroup</span>
            subgroup_sol(sub, step, low) = mean(win_avg_sol(step,lower_index));
            subgroup_sol(sub, step, mid) = mean(win_avg_sol(step,mean_index));
            subgroup_sol(sub, step, up)  = mean(win_avg_sol(step,upper_index));
            subgroup_ta(sub, step, low)  = mean(win_avg_ta(step,lower_index));
            subgroup_ta(sub, step, mid)  = mean(win_avg_ta(step,mean_index));
            subgroup_ta(sub, step, up)   = mean(win_avg_ta(step,upper_index));
        <span class="keyword">end</span> <span class="comment">% step</span>
    <span class="keyword">end</span> <span class="comment">% sub</span>

    <span class="comment">% Rearrange data to box plot data</span>
    step2 = 1; step4 = 2; step6 = 3;
    group_low_sol = [subgroup_sol(:,step2,low)' ; subgroup_sol(:,step4,low)' ; subgroup_sol(:,step6,low)' ; (subgroup_sol(:,step2,low)'+subgroup_sol(:,step4,low)'+subgroup_sol(:,step6,low)')./3]';
    group_mid_sol = [subgroup_sol(:,step2,mid)' ; subgroup_sol(:,step4,mid)' ; subgroup_sol(:,step6,mid)' ; (subgroup_sol(:,step2,mid)'+subgroup_sol(:,step4,mid)'+subgroup_sol(:,step6,mid)')./3]';
    group_up_sol =  [subgroup_sol(:,step2,up)' ; subgroup_sol(:,step4,up)' ; subgroup_sol(:,step6,up)' ; (subgroup_sol(:,step2,up)'+subgroup_sol(:,step4,up)'+subgroup_sol(:,step6,up)')./3]';
    x_sol = {group_low_sol, group_mid_sol, group_up_sol};

    group_low_ta = [subgroup_ta(:,step2,low)' ; subgroup_ta(:,step4,low)' ; subgroup_ta(:,step6,low)'; (subgroup_ta(:,step2,low)'+subgroup_ta(:,step4,low)'+subgroup_ta(:,step6,low)')./3]';
    group_mid_ta = [subgroup_ta(:,step2,mid)' ; subgroup_ta(:,step4,mid)' ; subgroup_ta(:,step6,mid)' ; (subgroup_ta(:,step2,mid)'+subgroup_ta(:,step4,mid)'+subgroup_ta(:,step6,mid)')./3]';
    group_up_ta =  [subgroup_ta(:,step2,up)' ; subgroup_ta(:,step4,up)' ; subgroup_ta(:,step6,up)'; (subgroup_ta(:,step2,up)'+subgroup_ta(:,step4,up)'+subgroup_ta(:,step6,up)')./3]';
    x_ta = {group_low_ta, group_mid_ta, group_up_ta};

    x_all = {(group_low_sol+group_low_ta)./2, (group_mid_sol+group_mid_ta)./2, (group_up_sol+group_up_ta)./2 } ;


    <span class="comment">% Plot boxplot for single subject</span>
    figure; hold <span class="string">on</span>;
    blue = 	[0 0 1]; red = [1 0 0]; gray = [150 152 158]/255;

    subplot(211)
        title(<span class="string">"Within step adjustment - All Subject"</span>,<span class="string">'FontName'</span>,<span class="string">'FixedWidth'</span>)
        grpLabels = {<span class="string">'Step 2'</span>, <span class="string">'Step 4'</span>, <span class="string">'Step 6'</span>, <span class="string">'All steps'</span>};
        sublabels = {<span class="string">'low'</span>, <span class="string">'mid'</span>, <span class="string">'up'</span>};
        <span class="comment">%plot([0 4],[100 200])</span>
        boxplotGroup(x_sol,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels, <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true, <span class="string">'Colors'</span>,[red; gray; blue],<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        <span class="comment">%ylim([YL_sol(1) YL_sol(2)])</span>
        ylim([0 0.5])
        ylabel(<span class="string">"Normalized muscle activity"</span>+newline+<span class="string">"Soleus"</span>)


    <span class="comment">% Plot boxplot for single subject</span>
    subplot(212);hold <span class="string">on</span>;
        boxplotGroup(x_ta,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels, <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true, <span class="string">'Colors'</span>,[red; gray; blue],<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        <span class="comment">%ylim([YL_ta(1) YL_ta(2)]</span>
        ylim([0 0.5])
        ylabel(<span class="string">"Normalized muscle activity"</span>+newline+<span class="string">"Tibialis"</span>)

fprintf(<span class="string">'done [ %4.2f sec ] \n'</span>, toc);
<span class="keyword">else</span>
fprintf(<span class="string">'disable \n'</span>);
<span class="keyword">end</span> <span class="comment">%show_plt</span>
</pre><pre class="codeoutput">script: TASK 2.3  . . . disable 
</pre><h2 id="21">Task 3.1 Horizontal perturbation.</h2><p>plot difference i hastighed ift soleus aktivitet som regression plot. 5 f&oslash;rste str&aelig;k mod 5 sidste str&aelig;k</p><pre class="codeinput">show_plt = false;
subject = 5;
before = 600;
after = 200;
xlimit = [-100 200];
firstSweep = false;
pltDiff = false;
oneSweep = true;
oneSweepNum = [8,11,13,14,15,16,17,19]

<span class="comment">%SUBJECT 2</span>
<span class="comment">% SOL:</span>
<span class="comment">% SLR : [1,16,18,19]</span>
<span class="comment">% MLR : [7,8,9,11,17,18]</span>
<span class="comment">% TA:</span>
<span class="comment">% SLR : [13,16,18]</span>
<span class="comment">% MLR : [1,3,5,16,18]</span>

<span class="comment">%SUBJECT 1</span>
<span class="comment">% SOL</span>
<span class="comment">% SLR : [2,10,12,14]</span>
<span class="comment">% MLR : [1,3,4,9,10,12,13,14,15,17,19]</span>
<span class="comment">% TA:</span>
<span class="comment">% SLR : [16,18]</span>
<span class="comment">% MLR : [</span>


<span class="comment">%SUBJECT 3</span>
<span class="comment">% SOL</span>
<span class="comment">% SLR : [2,4,8,13,14,16]</span>
<span class="comment">% MLR : [5,7,9,11,15]</span>
<span class="comment">% TA:</span>
<span class="comment">% SLR : [11]</span>
<span class="comment">% MLR : [11,12]</span>

<span class="comment">%SUBJECT 5</span>
<span class="comment">% SOL</span>
<span class="comment">% SLR : [8,18,19]</span>
<span class="comment">% MLR : [18]</span>
<span class="comment">% TA:</span>
<span class="comment">% SLR : [8,11,13,14,15,16,17,19]</span>
<span class="comment">% MLR : [1,7]</span>

clear <span class="string">offset</span>
<span class="keyword">switch</span> firstSweep
    <span class="keyword">case</span> true
        offset(1) = 18; <span class="comment">%30;</span>
        offset(2) = 13; <span class="comment">%38;</span>
        offset(3) = 19; <span class="comment">%19</span>
        offset(4) = 0;
        offset(5) = 10;  <span class="comment">%31;</span>
        offset(6) = 22;  <span class="comment">%31.5;</span>
        offset(7) = 18;  <span class="comment">%23;</span>
        offset(8) = 26;
    <span class="keyword">case</span> false
        offset(1) = 30;
        offset(2) = 38;
        offset(3) = 19;
        offset(4) = 0;
        offset(5) = 31;
        offset(6) = 31;
        offset(7) = 23;
        offset(8) = 26;
<span class="keyword">end</span>

<span class="comment">%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span>

<span class="keyword">if</span> show_plt
    data = total_data{1,1,subject};
    step_index = total_step{1,1,subject};
    type = total_type{1,1,subject}; yes = type{3}; no = type{4};

    clear <span class="string">temp_plot</span>
    temp_plot = cell(3,7);
    [temp_plot{HOR,:}] = func_align(step_index{HOR}, data{HOR,[1:4,6:7]}, <span class="string">'sec_before'</span>, ms2sec(before), <span class="string">'sec_after'</span>, ms2sec(after), <span class="string">'alignStep'</span>, <span class="string">"four_begin"</span>);
    x_axis = sec2ms(temp_plot{HOR, time});

    <span class="comment">%plot properties</span>
    no_color = [0.75, 0.75, 0.75];
    yes_color = <span class="string">"black"</span>;
    zero_color = <span class="string">"red"</span>;
    diff_color = <span class="string">"green"</span>;
    no_LineWidth = 3;
    yes_LineWidth = 1;
    zero_LineWidth = 1;


    <span class="comment">% patch properties</span>
    y_pat = [-1000 -1000 2000 2000];
    patchcolor_slr = <span class="string">"blue"</span> ; <span class="comment">%[251 244 199]/255;</span>
    patchcolor_mlr = <span class="string">"black"</span> ; <span class="comment">%[251 244 199]/255;</span>

    FaceAlpha = 0.2;
    EdgeColor = [37 137 70]/255;
    lineWidth_patch = 2;
    x_pat_SLR = [offset(subject)+39 offset(subject)+59 offset(subject)+59 offset(subject)+39];
    x_pat_MLR = [offset(subject)+59 offset(subject)+79 offset(subject)+79 offset(subject)+59];

    dep1 = find(floor(x_axis) == x_pat_SLR(1)); dep1 = dep1(1);
    dep2 = find(floor(x_axis) == x_pat_SLR(2)); dep2 = dep2(1);

    depM1 = find(floor(x_axis) == x_pat_MLR(1)); depM1 = depM1(1);
    depM2 = find(floor(x_axis) == x_pat_MLR(2)); depM2 = depM2(1);

    pre1 = find(floor(x_axis) == offset(subject)); pre1 = pre1(1);
    pre2 = find(floor(x_axis) == offset(subject)+20); pre2 = pre2(1);

    <span class="comment">% Check if a figure with the name 'TASK3' is open</span>
    fig = findobj(<span class="string">'Name'</span>, <span class="string">'TASK3'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
    figSize = [200 60 1000 700];
    figure(<span class="string">'Name'</span>,<span class="string">'TASK3'</span>,<span class="string">'Position'</span>, figSize)
    sgtitle(<span class="string">"Horizontal. Subject "</span> + subject)

    sensortype = ANG; <span class="comment">% position</span>
    subplot(4,4,1:3); hold <span class="string">on</span>;
        <span class="comment">% plot formalia (411)</span>
        title([<span class="string">'{\color{gray}Control sweeps [n='</span> num2str(length(no)) <span class="string">'].} Perturbation sweeps [n='</span> num2str(length(yes)) <span class="string">'].  {\color{red} Perturbation onset '</span> num2str(offset(subject)) <span class="string">' [ms] }'</span> ])
        subtitle(labels(sensortype))
        ylabel(labels_ms(sensortype))
        <span class="keyword">if</span> ~isempty(xlimit), xlim(xlimit); <span class="keyword">end</span>
        <span class="comment">% plot data (411)</span>
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,no_color)
        <span class="keyword">if</span> firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,<span class="string">"blue"</span>)
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,<span class="string">"red"</span>)
        <span class="keyword">end</span>
        <span class="keyword">if</span> pltDiff
           plot(x_axis, zeros(size(x_axis)), <span class="string">"color"</span>, <span class="string">"black"</span>)
            y =mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no(1:5),:),1);
           plot(x_axis , y, <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>, diff_color)
        <span class="keyword">end</span>

        <span class="keyword">if</span> oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),<span class="string">'LineWidth'</span>,yes_LineWidth ,<span class="string">'color'</span>,yes_color)
        <span class="keyword">else</span>
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,yes_color)
        <span class="keyword">end</span>
        YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)])
        plot([offset(subject) offset(subject)],[-100 100], <span class="string">'lineWidth'</span>, zero_LineWidth, <span class="string">'Color'</span>,zero_color)


    sensortype = VEL; <span class="comment">% velocity</span>
    subplot(4,4,5:7); hold <span class="string">on</span>;
        <span class="comment">% plot formalia (412)</span>
        subtitle(labels(sensortype))
        ylabel(labels_ms(sensortype))
        <span class="keyword">if</span> ~isempty(xlimit), xlim(xlimit); <span class="keyword">end</span>
        grid <span class="string">on</span>
        <span class="comment">% plot data (412)</span>
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,no_color)
        <span class="keyword">if</span> firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,<span class="string">"blue"</span>) <span class="comment">%</span>
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,<span class="string">"red"</span>)
        <span class="keyword">end</span>
        <span class="keyword">if</span> pltDiff
           y = mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no,:),1);
           plot(x_axis, zeros(size(x_axis)), <span class="string">"color"</span>, <span class="string">"black"</span>)
           plot(x_axis , y, <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>, diff_color)
        <span class="keyword">end</span>
        <span class="keyword">if</span> oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),<span class="string">'LineWidth'</span>,yes_LineWidth ,<span class="string">'color'</span>,yes_color)
        <span class="keyword">else</span>
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,yes_color)
        <span class="keyword">end</span>
        YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)])
        plot([offset(subject) offset(subject)],[-100 100], <span class="string">'lineWidth'</span>, zero_LineWidth, <span class="string">'Color'</span>,zero_color)


    sensortype = SOL; <span class="comment">% soleus</span>
    subplot(4,4,9:11); hold <span class="string">on</span>;
        <span class="comment">% plot formalia (413)</span>
        subtitle(labels(SOL))
        ylabel(labels(sensortype))
        <span class="comment">% plot data (413)</span>
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,no_color)
        <span class="keyword">if</span> firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,<span class="string">"Blue"</span>)
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,<span class="string">"red"</span>)
        <span class="keyword">end</span>
       <span class="keyword">if</span> pltDiff
           y = mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no,:),1);
           plot(x_axis, zeros(size(x_axis)), <span class="string">"color"</span>, <span class="string">"black"</span>)
           plot(x_axis , y, <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>, diff_color)
       <span class="keyword">end</span>
       <span class="keyword">if</span> oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),<span class="string">'LineWidth'</span>,yes_LineWidth ,<span class="string">'color'</span>,yes_color)
        <span class="keyword">else</span>
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,yes_color)
        <span class="keyword">end</span>
        YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)])
        plot([offset(subject) offset(subject)],[-100 100], <span class="string">'lineWidth'</span>, zero_LineWidth, <span class="string">'Color'</span>,zero_color)
        <span class="keyword">if</span> ~isempty(xlimit), xlim(xlimit); <span class="keyword">end</span>
        patch(x_pat_SLR,y_pat,patchcolor_slr,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, <span class="string">"none"</span>)
        patch(x_pat_MLR,y_pat,patchcolor_mlr,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, <span class="string">"none"</span>)

    subplot(4,4,12); hold <span class="string">on</span>;
        ylabel(<span class="string">"avg. SOL"</span>);
        xlabel(<span class="string">"avg. POS"</span>)

        clear <span class="string">dependSLR</span> <span class="string">dependMLR</span> <span class="string">predict</span>
        <span class="keyword">if</span> ~pltDiff
            dependSLR(:) = mean(temp_plot{HOR,sensortype}(yes,[dep1:dep2]),2);
            dependMLR(:) = mean(temp_plot{HOR,sensortype}(yes,[depM1:depM2]),2);
        <span class="keyword">else</span>
            signal = temp_plot{HOR,sensortype}(yes,:) - temp_plot{HOR,sensortype}(no(1:numel(yes)),:);
            dependSLR(:) = mean(signal(:,[dep1:dep2]),2);
            dependMLR(:) = mean(signal(:,[depM1:depM2]),2);
        <span class="keyword">end</span>
        <span class="comment">%predict(:) = mean(temp_plot{HOR,ANG}(yes,[pre1:pre2]),2);</span>
        predict(:) = (temp_plot{HOR,ANG}(yes,pre1) - temp_plot{HOR,ANG}(yes,pre2))/diff([pre1,pre2]);
        mdl_slr = fitlm(predict(:), dependSLR(:));   <span class="comment">% &lt;--- SIG</span>
        mdl_mlr = fitlm(predict(:), dependMLR(:));   <span class="comment">% &lt;--- SIG</span>
        b_slr = table2array(mdl_slr.Coefficients(1,1)); a_slr = table2array(mdl_slr.Coefficients(2,1));
        b_mlr = table2array(mdl_mlr.Coefficients(1,1)); a_mlr = table2array(mdl_mlr.Coefficients(2,1));
        linearReg_slr = @(x) x*a_slr + b_slr;
        linearReg_mlr = @(x) x*a_mlr + b_mlr;
        <span class="keyword">if</span> table2array(mdl_slr.Coefficients(2,4)) &lt; 0.05
            plot(predict, linearReg_slr(predict), <span class="string">"color"</span>, <span class="string">"red"</span>, <span class="string">'lineWidth'</span>,2)
        <span class="keyword">end</span>
        <span class="keyword">if</span> table2array(mdl_mlr.Coefficients(2,4)) &lt; 0.05
            plot(predict, linearReg_mlr(predict), <span class="string">"color"</span>, <span class="string">"red"</span>, <span class="string">'lineWidth'</span>,2)
        <span class="keyword">end</span>

        plot(predict, linearReg_slr(predict), <span class="string">"color"</span>, <span class="string">"blue"</span>)
        plot(predict, linearReg_mlr(predict), <span class="string">"color"</span>, <span class="string">"black"</span>)
        plot(predict, dependSLR, <span class="string">'p'</span>, <span class="string">"color"</span>, <span class="string">"blue"</span>)
        plot(predict, dependMLR, <span class="string">'p'</span>, <span class="string">"color"</span>, <span class="string">"black"</span>)


    sensortype = TA; <span class="comment">% tibialis</span>
    subplot(4,4,13:15); hold <span class="string">on</span>;
        <span class="comment">% plot formalia (414)</span>
        subtitle(labels(sensortype))
        ylabel(labels(sensortype))
        xlabel(labels_ms(time))
        <span class="comment">% plot data (414)</span>
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,no_color)
        <span class="keyword">if</span> firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), <span class="string">'LineWidth'</span>,no_LineWidth, <span class="string">'Color'</span>,<span class="string">"blue"</span>)
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,<span class="string">"red"</span>)
        <span class="keyword">end</span>
        <span class="keyword">if</span> pltDiff
           y = mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no,:),1);
           plot(x_axis, zeros(size(x_axis)), <span class="string">"color"</span>, <span class="string">"black"</span>)
           plot(x_axis , y, <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>, diff_color)
        <span class="keyword">end</span>
        <span class="keyword">if</span> oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),<span class="string">'LineWidth'</span>,yes_LineWidth ,<span class="string">'color'</span>,yes_color)
        <span class="keyword">else</span>
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), <span class="string">'LineWidth'</span>,yes_LineWidth, <span class="string">'Color'</span>,yes_color)
        <span class="keyword">end</span>
        YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)])
        plot([offset(subject) offset(subject)],[-100 100], <span class="string">'lineWidth'</span>, zero_LineWidth, <span class="string">'Color'</span>,zero_color)
        <span class="keyword">if</span> ~isempty(xlimit), xlim(xlimit); <span class="keyword">end</span>
        patch(x_pat_SLR,y_pat,patchcolor_slr,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, <span class="string">"none"</span>)
        patch(x_pat_MLR,y_pat,patchcolor_mlr,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, <span class="string">"none"</span>)

    <span class="comment">% Pos vs TA</span>
    subplot(4,4,16); hold <span class="string">on</span>;
        clear <span class="string">dependSLR</span> <span class="string">dependMLR</span> <span class="string">predict</span>
        <span class="keyword">if</span> ~pltDiff
            dependSLR(:) = mean(temp_plot{HOR,sensortype}(yes,[dep1:dep2]),2);
            dependMLR(:) = mean(temp_plot{HOR,sensortype}(yes,[depM1:depM2]),2);
        <span class="keyword">else</span>
            signal = temp_plot{HOR,sensortype}(yes,:) - temp_plot{HOR,sensortype}(no(1:numel(yes)),:);
            dependSLR(:) = mean(signal(:,[dep1:dep2]),2);
            dependMLR(:) = mean(signal(:,[depM1:depM2]),2);
        <span class="keyword">end</span>
        <span class="comment">%predict(:) = mean(temp_plot{HOR,ANG}(yes,[pre1:pre2]),2);</span>
        predict(:) = (temp_plot{HOR,ANG}(yes,pre1) - temp_plot{HOR,ANG}(yes,pre2))/diff([pre1,pre2]);
        mdl_slr = fitlm(predict(:), dependSLR(:));   <span class="comment">% &lt;--- SIG</span>
        mdl_mlr = fitlm(predict(:), dependMLR(:));   <span class="comment">% &lt;--- SIG</span>
        b_slr = table2array(mdl_slr.Coefficients(1,1)); a_slr = table2array(mdl_slr.Coefficients(2,1));
        b_mlr = table2array(mdl_mlr.Coefficients(1,1)); a_mlr = table2array(mdl_mlr.Coefficients(2,1));
        p_value = table2array(mdl_slr.Coefficients(2,4));
        linearReg_slr = @(x) x*a_slr + b_slr;
        linearReg_mlr = @(x) x*a_mlr + b_mlr;
        <span class="keyword">if</span> table2array(mdl_slr.Coefficients(2,4)) &lt; 0.05
            plot(predict, linearReg_slr(predict), <span class="string">"color"</span>, <span class="string">"red"</span>, <span class="string">'lineWidth'</span>,2)
        <span class="keyword">end</span>
        <span class="keyword">if</span> table2array(mdl_mlr.Coefficients(2,4)) &lt; 0.05
            plot(predict, linearReg_mlr(predict), <span class="string">"color"</span>, <span class="string">"red"</span>, <span class="string">'lineWidth'</span>,2)
        <span class="keyword">end</span>
        plot(predict, linearReg_slr(predict), <span class="string">"color"</span>, <span class="string">"blue"</span>)
        plot(predict, linearReg_mlr(predict), <span class="string">"color"</span>, <span class="string">"black"</span>)
        plot(predict, dependSLR, <span class="string">'p'</span>, <span class="string">"color"</span>, <span class="string">"blue"</span>)
        plot(predict, dependMLR, <span class="string">'p'</span>, <span class="string">"color"</span>, <span class="string">"black"</span>)
        ylabel(<span class="string">"avg. TA"</span>);
        xlabel(<span class="string">"avg. POS"</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">
oneSweepNum =

     8    11    13    14    15    16    17    19

</pre><h2 id="22">Task 3.2 Horizontal perturbation boxplot</h2><p>Show boxplot where all subject can clearly be identified.</p><pre class="codeinput">show_plt = false;
inc_sub_hor = [1,2,3,4,5,6,7,8];


<span class="comment">%   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .</span>
cnt = 0;
SLR = 1; MLR = 2;
clear <span class="string">h_pert</span>
h_pert = struct;

<span class="keyword">if</span> firstSweep
    box_dim = 1:5;
<span class="keyword">else</span>
    box_dim = 1:19;
<span class="keyword">end</span>

<span class="keyword">if</span> show_plt
    clear <span class="string">avg_CTL</span> <span class="string">avg_CTL</span>
    <span class="keyword">for</span> sub = inc_sub_hor
        cnt = cnt + 1;
        data = total_data{1,1,sub};
        step_index = total_step{1,1,sub};
        type = total_type{1,1,sub}; yes = type{3}; no = type{4};

        clear <span class="string">temp_data</span>
        temp_data = cell(3,7);
        [temp_data{HOR,:}] = func_align(step_index{HOR}, data{HOR,[1:4,6:7]}, <span class="string">'alignStep'</span>, <span class="string">"four_begin"</span>);

        <span class="comment">% Define window for each subject</span>
        SLR_begin = floor(ms2sec(offset(sub)+39)*Fs); SLR_end = floor(ms2sec(offset(sub)+59)*Fs); <span class="comment">% [length=41]</span>
        MLR_begin = floor(ms2sec(offset(sub)+60)*Fs); MLR_end = floor(ms2sec(offset(sub)+80)*Fs); <span class="comment">% [length=41]</span>

        <span class="keyword">for</span> muscle = [SOL, TA]
            <span class="comment">% Short lantency reflex</span>
            h_pert.CTL(cnt,muscle,SLR,:) = mean(temp_data{HOR,muscle}(no(box_dim) , [SLR_begin : SLR_end]),(2));
            h_pert.HOR(cnt,muscle,SLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [SLR_begin : SLR_end]),(2));

            <span class="comment">% Medium lantency reflex</span>
            h_pert.CTL(cnt,muscle,MLR,:) = mean(temp_data{HOR,muscle}(no(box_dim) , [MLR_begin : MLR_end]),(2));
            h_pert.HOR(cnt,muscle,MLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [MLR_begin : MLR_end]),(2));

            <span class="keyword">if</span> pltDiff
                h_pert.diff(cnt,muscle,SLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [SLR_begin : SLR_end]),(2)) - mean(temp_data{HOR,muscle}(no(box_dim), [SLR_begin : SLR_end]),(2));
                h_pert.diff(cnt,muscle,MLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [SLR_begin : SLR_end]),(2)) - mean(temp_data{HOR,muscle}(no(box_dim), [SLR_begin : SLR_end]),(2));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% sub</span>

    <span class="comment">% Box plot data arrangement, all subject</span>
    x_sol_control = [mean(squeeze(h_pert.CTL(:,SOL,SLR,:)),2)' ; mean(squeeze(h_pert.CTL(:,SOL,MLR,:)),2)'];
    x_sol_pert    = [mean(squeeze(h_pert.HOR(:,SOL,SLR,:)),2)' ; mean(squeeze(h_pert.HOR(:,SOL,MLR,:)),2)'];
    x_ta_control  = [mean(squeeze(h_pert.CTL(:,TA,SLR,:)),2)'  ; mean(squeeze(h_pert.CTL(:,TA,MLR,:)),2)'  ];
    x_ta_pert     = [mean(squeeze(h_pert.HOR(:,TA,SLR,:)),2)'  ; mean(squeeze(h_pert.HOR(:,TA,MLR,:)),2)'];
    box_soleus   = {x_sol_control', x_sol_pert'};
    box_tibialis = {x_ta_control', x_ta_pert'};

    <span class="comment">% Box plot data arrangement, individuel subject</span>
    box_soleus_slr   = {squeeze(h_pert.CTL(:,SOL,SLR,:))',squeeze(h_pert.HOR(:,SOL,SLR,:))'};
    box_tibialis_slr = {squeeze(h_pert.CTL(:,TA,SLR,:))',squeeze(h_pert.HOR(:,TA,SLR,:))'};
    box_soleus_mlr   = {squeeze(h_pert.CTL(:,SOL,MLR,:))',squeeze(h_pert.HOR(:,SOL,MLR,:))'};
    box_tibialis_mlr = {squeeze(h_pert.CTL(:,TA,MLR,:))',squeeze(h_pert.HOR(:,TA,MLR,:))'};

    <span class="comment">% Box plot data arrangement, difference</span>
    <span class="keyword">if</span> pltDiff
        box_diff_sol = {mean(squeeze(h_pert.diff(:,muscle,SLR,:)),2),mean(squeeze(h_pert.diff(:,muscle,MLR,:)),2) };
        box_diff_ta  = {mean(squeeze(h_pert.diff(:,muscle,TA ,:)),2),mean(squeeze(h_pert.diff(:,muscle,TA ,:)),2) };
    <span class="keyword">end</span>


    <span class="comment">% Group labels for boxplot</span>
    sublabels = {<span class="string">'CTL'</span>, <span class="string">'HOR'</span>};
    grpLabels = {<span class="string">'1'</span>, <span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>};
    grpLabels_conditions = {<span class="string">'SLR'</span>, <span class="string">'MLR'</span>};

    <span class="keyword">if</span> pltDiff

        fig = findobj(<span class="string">'Name'</span>, <span class="string">'Difference'</span>);
        <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
        figure(<span class="string">'Name'</span>,<span class="string">'Difference'</span>) ;
        sgtitle(<span class="string">"Horizontal Difference. Mean(pert) - mean(control)"</span>)
        subplot(211); hold <span class="string">on</span>
            plot([0,3], [0,0], <span class="string">'color'</span>, <span class="string">"black"</span>)
            boxplotGroup(box_diff_sol,<span class="string">'primaryLabels'</span>,grpLabels_conditions)
            title(<span class="string">"Normalized Soleus EMG"</span>)
            grid <span class="string">on</span>;
        subplot(212); hold <span class="string">on</span>
            plot([0,3], [0,0], <span class="string">'color'</span>, <span class="string">"black"</span>)
            boxplotGroup(box_diff_ta,<span class="string">'primaryLabels'</span>,grpLabels_conditions)
            title(<span class="string">"Normalized Tibialis EMG"</span>)
            grid <span class="string">on</span>;
    <span class="keyword">end</span>

    fig = findobj(<span class="string">'Name'</span>, <span class="string">'All subject'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
    figure(<span class="string">'Name'</span>,<span class="string">'All subject'</span>)
    sgtitle(<span class="string">"Horizontal perturbation. FirstSweep: "</span> + firstSweep)
    subplot(211)
        boxplotGroup(box_soleus,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels_conditions, <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        ylabel(<span class="string">"Normalized"</span>+newline+<span class="string">"Soleus avtivity"</span>)
    subplot(212)
        boxplotGroup(box_tibialis,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels_conditions, <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        ylabel(<span class="string">"Normalized"</span>+newline+<span class="string">"Tibialis avtivity"</span>)

    <span class="comment">% Boxplot of individuel subject</span>
    figSize = [100 200 1300 400];
    fig = findobj(<span class="string">'Name'</span>, <span class="string">'Indiv sub'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>
    figure(<span class="string">'Name'</span>,<span class="string">'Indiv sub'</span>,<span class="string">'Position'</span>, figSize)
    sgtitle(<span class="string">"Horizontal perturbation. FirstSweep: "</span> + firstSweep)
    subplot(411);
        boxplotGroup(box_soleus_slr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(inc_sub_hor), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        title(<span class="string">"Short Latency reflex - Soleus"</span>)
        ylabel(<span class="string">"SLR"</span>+newline+<span class="string">"avg. Soleus"</span>)
    subplot(412)
        title(<span class="string">"Short Latency reflex - Tibialis"</span>)
        boxplotGroup(box_tibialis_slr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(inc_sub_hor), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        ylabel(<span class="string">"SLR"</span>+newline+<span class="string">"avg. Tibialis"</span>)
    subplot(413);
        title(<span class="string">"Medium Latency reflex - Soleus"</span>)
        boxplotGroup(box_soleus_mlr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(inc_sub_hor), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        ylabel(<span class="string">"MLR"</span>+newline+<span class="string">"avg. Soleus"</span>)
    subplot(414)
        title(<span class="string">"Medium Latency reflex - Tibialis"</span>)
        boxplotGroup(box_tibialis_mlr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(inc_sub_hor), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
        ylabel(<span class="string">"MLR"</span>+newline+<span class="string">"avg. Tibialis"</span>)
        xlabel(<span class="string">"Subject"</span>)
<span class="keyword">end</span>
</pre><h2 id="23">Task 4.1 Vertical perturbation</h2><pre class="codeinput">fprintf(<span class="string">'script: TASK 4.1  . . . '</span>); tic

show_plt = false;
show_boxplt = true;
subject = 8;
x_range = [-400 200];
plt_show = [ANG, VEL, SOL, TA];
box_dim = 1:11;
savepgn = false;

<span class="keyword">if</span> included_vertical_data_processing

<span class="comment">% Defined size for window-analysis</span>
SLR = 1; MLR = 2;
pre_search = [0 , 20]; <span class="comment">% denoted in ms</span>
SLR_search = [39, 59]; <span class="comment">% denoted in ms</span>
MLR_search = [60, 80]; <span class="comment">% denoted in ms</span>

<span class="comment">%   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .</span>
<span class="comment">% Load data</span>
data = total_data_vertical{1,1,subject};
type = total_type_vertical{1,1,subject}; no = type{2}; yes = type{1};
x_axis = data{VER,time};

<span class="comment">% for i=1:numel(names_indiv)</span>
<span class="comment">% type = total_type_vertical{1,1,i}; no = type{2}; yes = type{1};</span>
<span class="comment">% numel(yes)</span>
<span class="comment">% end</span>


<span class="comment">% Patch pr operties</span>
patchcolor = [251 244 199]/255;
FaceAlpha = 0.4;
patX_predict = [pre_search(1) pre_search(2) pre_search(2) pre_search(1)];    <span class="comment">% ms</span>
patX_slr     = [SLR_search(1) SLR_search(2) SLR_search(2) SLR_search(1)];    <span class="comment">% ms</span>
patX_mlr     = [MLR_search(1) MLR_search(2) MLR_search(2) MLR_search(1)];    <span class="comment">% ms</span>
patY = [-1000 -1000 1000 1000];
EdgeColor = [37 137 70]/255;
lineWidth_patch = 0.5;

<span class="keyword">if</span> show_plt
    <span class="comment">% Plot properties</span>
    color_no = [0.75, 0.75, 0.75];
    color_yes = <span class="string">"black"</span>;
    linewidth_no = 3;
    linewidth_yes = 1;


    <span class="comment">% Check if a figure with the name 'TASK3' is open</span>
    fig = findobj(<span class="string">'Name'</span>, <span class="string">'Vertical Perturbation'</span>);
    <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>

    <span class="comment">% Begin plot</span>
    figure(<span class="string">'Name'</span>, <span class="string">'Vertical Perturbation'</span>); hold <span class="string">on</span>;
    sgtitle(<span class="string">"Subject: "</span> + subject)
    <span class="keyword">for</span> i = 1:numel(plt_show)
        subplot(numel(plt_show), 1, i); hold <span class="string">on</span>
        ylabel(labels_ms(plt_show(i)))
        xlim(x_range)

        plot(x_axis, mean(data{VER,plt_show(i)}(no(box_dim),:),1), <span class="string">'color'</span>, color_no, <span class="string">"linewidth"</span>, linewidth_no)
        plot(x_axis, mean(data{VER,plt_show(i)}(yes(box_dim),:),1), <span class="string">'color'</span>, color_yes, <span class="string">"linewidth"</span>, linewidth_yes)
        YL = get(gca, <span class="string">'YLim'</span>); ylim([YL(1) YL(2)]);

        <span class="keyword">if</span> or(plt_show(i) == ANG, plt_show(i) == VEL)
            patch(patX_predict, patY, patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, EdgeColor, <span class="string">'LineWidth'</span>, lineWidth_patch)
        <span class="keyword">else</span>
            patch(patX_slr, patY, patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, EdgeColor, <span class="string">'LineWidth'</span>, lineWidth_patch)
            patch(patX_mlr, patY, patchcolor,<span class="string">'FaceAlpha'</span>,FaceAlpha, <span class="string">'EdgeColor'</span>, EdgeColor, <span class="string">'LineWidth'</span>, lineWidth_patch)
        <span class="keyword">end</span>

        set(gca, <span class="string">'Layer'</span>, <span class="string">'top'</span>)
        plot(x_axis, mean(data{VER,plt_show(i)}(no(box_dim),:),1), <span class="string">'color'</span>, color_no, <span class="string">"linewidth"</span>, linewidth_no)
        plot(x_axis, mean(data{VER,plt_show(i)}(yes(box_dim),:),1), <span class="string">'color'</span>, color_yes, <span class="string">"linewidth"</span>, linewidth_yes)
    <span class="keyword">end</span>
    filename = <span class="string">"Subject"</span>+subject+<span class="string">".png"</span>;
    filepath = <span class="string">'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/vertical/'</span>;
    fullpath = fullfile(filepath, filename);
    <span class="keyword">if</span> savepgn
        saveas(gcf, fullpath, <span class="string">'png'</span>);
    <span class="keyword">end</span>


    <span class="keyword">if</span> show_boxplt
        <span class="comment">% Boxplot</span>
        v_pert = struct;
        <span class="keyword">for</span> sub = 1:numel(names_indiv)
            data = total_data_vertical{1,1,sub};
            type = total_type_vertical{1,1,sub}; no = type{2}; yes = type{1};
            x_axis = data{VER,time};

            pre_search_sample = [find(pre_search(1) == x_axis), find(pre_search(2) == x_axis)];
            SLR_search_sample = [find(SLR_search(1) == x_axis), find(SLR_search(2) == x_axis)];
            MLR_search_sample = [find(MLR_search(1) == x_axis), find(MLR_search(2) == x_axis)];

    <span class="comment">%         if sub== subject</span>
    <span class="comment">%             figure;</span>
    <span class="comment">%             subplot(211); hold on</span>
    <span class="comment">%             plot([SLR_search_sample(1):SLR_search_sample(2)], mean(data{VER,SOL}(no(box_dim),  [SLR_search_sample(1):SLR_search_sample(2)]),1), "color", "blue")</span>
    <span class="comment">%             plot([SLR_search_sample(1):SLR_search_sample(2)], mean(data{VER,SOL}(yes(box_dim), [SLR_search_sample(1):SLR_search_sample(2)]),1), "color", "black")</span>
    <span class="comment">%</span>
    <span class="comment">%             subplot(212), hold on</span>
    <span class="comment">%             plot(mean(data{VER,SOL}(no(box_dim),  :), 1), "color", "blue")</span>
    <span class="comment">%             plot(mean(data{VER,SOL}(yes(box_dim), :), 1), "color", "black")</span>
    <span class="comment">%             plot([SLR_search_sample(1), SLR_search_sample(1)], [0,3])</span>
    <span class="comment">%             plot([SLR_search_sample(2), SLR_search_sample(2)], [0,3])</span>
    <span class="comment">%         end</span>


            <span class="keyword">for</span> muscle = [SOL, TA]
                <span class="comment">% Short lantency reflex</span>
                v_pert.CTL(sub,muscle,SLR,:) = mean(data{VER,muscle}(no(box_dim) , [SLR_search_sample(1):SLR_search_sample(2)]), 2);
                v_pert.VER(sub,muscle,SLR,:) = mean(data{VER,muscle}(yes(box_dim), [SLR_search_sample(1):SLR_search_sample(2)]), 2);

                <span class="comment">% Medium lantency reflex</span>
                v_pert.CTL(sub,muscle,MLR,:) = mean(data{VER,muscle}(no(box_dim),  [MLR_search_sample(1):MLR_search_sample(2)]), 2);
                v_pert.VER(sub,muscle,MLR,:) = mean(data{VER,muscle}(yes(box_dim), [MLR_search_sample(1):MLR_search_sample(2)]), 2);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="comment">% Group labels for boxplot</span>
        sublabels = {<span class="string">'CTL'</span>, <span class="string">'VER'</span>};
        grpLabels = {<span class="string">'1'</span>, <span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>};
        grpLabels_conditions = {<span class="string">'SLR'</span>, <span class="string">'MLR'</span>};

        <span class="comment">% Ny boxplot</span>
        v_box_soleus_slr   = {squeeze(v_pert.CTL(:,SOL,SLR,:))',squeeze(v_pert.VER(:,SOL,SLR,:))'};
        v_box_soleus_mlr   = {squeeze(v_pert.CTL(:,SOL,MLR,:))',squeeze(v_pert.VER(:,SOL,MLR,:))'};
        v_box_sol_slr_avg  = {squeeze(mean(v_pert.CTL(:,SOL,SLR,:),4)), squeeze(mean(v_pert.VER(:,SOL,SLR,:),4))};
        v_box_sol_mlr_avg  = {squeeze(mean(v_pert.CTL(:,SOL,MLR,:),4)), squeeze(mean(v_pert.VER(:,SOL,MLR,:),4))};

        <span class="comment">% Ny boxplot</span>
        v_box_tibialis_slr   = {squeeze(v_pert.CTL(:,TA,SLR,:))',squeeze(v_pert.VER(:,TA,SLR,:))'};
        v_box_tibialis_mlr   = {squeeze(v_pert.CTL(:,TA,MLR,:))',squeeze(v_pert.VER(:,TA,MLR,:))'};
        v_box_ta_slr_avg  = {squeeze(mean(v_pert.CTL(:,TA,SLR,:),4)), squeeze(mean(v_pert.VER(:,TA,SLR,:),4))};
        v_box_ta_mlr_avg  = {squeeze(mean(v_pert.CTL(:,TA,MLR,:),4)), squeeze(mean(v_pert.VER(:,TA,MLR,:),4))};



        <span class="comment">% Check if a figure with the name 'TASK3' is open</span>
        fig = findobj(<span class="string">'Name'</span>, <span class="string">'Vertical box plot'</span>);
        <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>

        <span class="comment">% Begin plot</span>
        figure(<span class="string">'Name'</span>, <span class="string">'Vertical box plot'</span>); hold <span class="string">on</span>;
        subplot(2,4,1:3)
            boxplotGroup(v_box_soleus_slr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(1:numel(names_indiv)), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
            title(<span class="string">"Short lantency reflex"</span>)
            xlabel(<span class="string">"Subject"</span>)
            ylabel(<span class="string">"Normalized"</span>+newline+<span class="string">"Soleus"</span>)
        subplot(2,4,4)
            boxplotGroup(v_box_sol_slr_avg, <span class="string">'primaryLabels'</span>,sublabels)
            title(<span class="string">"Grouped all subjects"</span>)
        subplot(2,4,5:7)
            boxplotGroup(v_box_soleus_mlr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(1:numel(names_indiv)), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
            ylabel(labels(TA))
            title(<span class="string">"Medium lantency reflex"</span>)
            xlabel(<span class="string">"Subject"</span>)
            ylabel(<span class="string">"Normalized"</span>+newline+<span class="string">"Soleus"</span>)
        subplot(2,4,8)
            boxplotGroup(v_box_sol_mlr_avg, <span class="string">'primaryLabels'</span>,sublabels)
            title(<span class="string">"Grouped all subjects"</span>)


        <span class="comment">% Check if a figure with the name 'TASK3' is open</span>
        fig = findobj(<span class="string">'Name'</span>, <span class="string">'Vertical box plot2'</span>);
        <span class="keyword">if</span> ~isempty(fig), close(fig); <span class="keyword">end</span>

        <span class="comment">% Begin plot</span>
        figure(<span class="string">'Name'</span>, <span class="string">'Vertical box plot2'</span>); hold <span class="string">on</span>;
        subplot(2,4,1:3)
            boxplotGroup(v_box_tibialis_slr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(1:numel(names_indiv)), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
            title(<span class="string">"Short lantency reflex"</span>)
            xlabel(<span class="string">"Subject"</span>)
            ylabel(<span class="string">"Normalized"</span>+newline+<span class="string">"Tibialis"</span>)
        subplot(2,4,4)
            boxplotGroup(v_box_ta_slr_avg, <span class="string">'primaryLabels'</span>,sublabels)
            title(<span class="string">"Grouped all subjects"</span>)
        subplot(2,4,5:7)
            boxplotGroup(v_box_tibialis_mlr,<span class="string">'primaryLabels'</span>,sublabels,<span class="string">'SecondaryLabels'</span>,grpLabels(1:numel(names_indiv)), <span class="string">'interGroupSpace'</span>,2,<span class="string">'GroupLines'</span>,true,<span class="string">'GroupType'</span>,<span class="string">'betweenGroups'</span>)
            ylabel(labels(TA))
            title(<span class="string">"Medium lantency reflex"</span>)
            xlabel(<span class="string">"Subject"</span>)
            ylabel(<span class="string">"Normalized"</span>+newline+<span class="string">"Tibialis"</span>)
        subplot(2,4,8)
            boxplotGroup(v_box_ta_mlr_avg, <span class="string">'primaryLabels'</span>,sublabels)
            title(<span class="string">"Grouped all subjects"</span>)

    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">script: TASK 4.1  . . . </pre><h2 id="24">Task 5.0 Pre-baseline vs Post-baseline</h2><p>Does the spinal influence chance due to the experienced protocols.</p><h2 id="25">Task 5.0 Show individual Unload trials</h2><h2 id="26">Task 6.0 make foot movement graph</h2><h2 id="27">finsihed</h2><pre class="codeinput">fprintf(<span class="string">'\n\n Processed finished \n'</span>)

<span class="comment">%  title(['Black graph, Sweep data. {\color{gray} Gray graph, Mean data [n=' num2str(sweepNum) '].}'])</span>

<span class="comment">% % Check if a figure with the name 'TASK3' is open</span>
<span class="comment">% fig = findobj('Name', 'Vertical Perturbation');</span>
<span class="comment">% % If a figure is found, close it</span>
<span class="comment">% if ~isempty(fig), close(fig); end</span>
</pre><pre class="codeoutput">

 Processed finished 
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021b</a><br></p></div><!--
##### SOURCE BEGIN #####
clc 
clear; 
close all; 

%% Folders 

included_vertical_data_processing = false; 
if included_vertical_data_processing == false
    msg = 'Vertical data processing is disabled \n'; 
    fprintf(2,msg); 
end

fprintf('script: Folder . . . '); tic

names = ["thomas", "benedikte", "andreas",  "andrew", "gritt", "maria", "trine",  "trine2", "Christian", "Soeren"]; % "mia" excluded
names_indiv = ["andreas", "andrew", "benedikte", "gritt", "maria", "thomas", "trine", "trine2"]; % "mia" excluded
% CTL2: andrew, Gritt, thomas, Mia, Trine, Trine 2

% Define data path
addpath("C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/FunctionFiles")
    
folderpath_preprocessed_data = "C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/data_preprocessed/"; 
folderpath_individuel_data = "C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/Indiv_data/"; 


% Preallocation
total_data = cell(1,1,numel(names));
total_type = cell(1,1,numel(names)); 
total_step = cell(1,1,numel(names)); 

if included_vertical_data_processing
    % Load vertical data 
    for i = 1:numel(names_indiv)
        load(folderpath_individuel_data + names_indiv(i) + ".mat" ); 
        total_data_vertical{:,:,i} = data_indiv; 
    
        load(folderpath_individuel_data + names_indiv(i) + "_type.mat"); 
        total_type_vertical{:,:,i} = type;
    end
end 

% Load preproccessed data  
for i = 1:length(names)
    load(folderpath_preprocessed_data + names(i) + "_data.mat");   total_data{:,:,i} = data; % size(data) = [3,4]
    % example: data{protocol, sensor}(sweep, data number)

    load(folderpath_preprocessed_data + names(i) + "_type.mat");   total_type{:,:,i} = type; % size(type) = [1,4]
    % example: type{1:2} = [VER_yes, VER_no]; type{3:4} = [HOR_yes, HOR_no]; 

    load(folderpath_preprocessed_data + names(i) + "_step.mat");   total_step{:,:,i} = step_index; % size(step_index) = [3,1]
    % example: step_index{protocol}(sweep, step)
end 

fprintf('done [ %4.2f sec ] \n', toc);

%% Abbreviation
fprintf('script: Abbreviation . . . '); tic

% protocol abbreviation types
CTL = 1; VER = 2; HOR = 3; CTL2 = 4; 
proto_all = [CTL, VER, HOR];

% Sensor abbreviation type
SOL = 1; TA = 2; ANG = 3; FSR = 4; time = 5; VEL = 6; ACC = 7;

% Plotting labels 
labels = ["Soleus"; "Tibialis"; "Position"; "";  ""; "Velocity"; "Acceleration"];
labels_ms = ["Soleus"+newline+"[\muV]";"Tibialis"+newline+"[\muV]"; "Position"+newline+"[Deg]";  "";  "Time"+newline+"[ms]"; "Velocity"+newline+"[Deg/ms]";"Acceleration"+newline+"[Deg/ms^2]"];
labels_sec = ["Soleus"+newline+"[\muV]";"Tibialis"+newline+"[\muV]"; "Position"+newline+"[Deg]"; "";  "Time"+newline+"[sec]";"Velocity"+newline+"[Deg/s]";"Acceleration"+newline+"[Deg/s^2]"];

% Global arrays
align_with_obtions = ["second_begin", "four_begin", "six_begin"];
steps_tested = [2,4,6];

% Global function
ms2sec = @(x) x*10^-3;         % Ms to sec 
sec2ms = @(x) x*10^3;          % Sec to ms 

% Global window definition
screensize = get(0,'ScreenSize');
width = screensize(3);
height = screensize(4);

fprintf('done [ %4.2f sec ] \n', toc);

%% Acquisition Set-Up
fprintf('script: Acquisition Set-Up . . . '); tic; 

sweep_length = 10;              % Signal length in second
Fs = 2000;                      % Samples per second
dt = 1/Fs;                      % Seconds per sample
pre_trig = 4;                   % Pre-trigger 
N = Fs*sweep_length;            % Total number of samples per signal

fprintf('done [ %4.2f sec ] \n', toc);

%% Readjust data to Local Peak instead of FSR 
fprintf('script: Readjust data to Local Peak instead of FSR . . .'); tic
readjust = true; 
show_gui = false; 
gui_subject = 10; 


%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
folderpath = "C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/Subject_offsets/"; 
filename = 1+"offset.mat";


error = zeros(numel(proto_all), numel(names),100); % 3x10x100
if readjust 
    for sub = 1:numel(names) % loop through subjects 
        % Some subject only completed one protocol. 
        if any(strcmp(names(sub), ["Christian", "Soeren"])) 
            protocols = [CTL]; 
        else 
            protocols = proto_all; 
        end
        
        % Check if an already defined offset file exist for subject 
        filename = sub+"offset.mat";
        filepath = fullfile(folderpath, filename);
        if exist(filepath, 'file') == 2
            load(filepath) % return 4x1 cell array called 'offset'
            total_step{1,1,sub} = offset; 
        
        % Create offset automatically if no file exist 
        else 
            data = total_data{1,1,sub};         % load data
            step_index = total_step{1,1,sub};   % load foot placement
            for proto = protocols 
                for sweep = 1:size(data{proto,ANG},1) % loop through sweeps        
                    for step = 1:3  % loop through steps   
                        
                        % Find template around foot-strike
                        [rise_num, ~] = func_find_edge(steps_tested(step));   
                        rise_index = step_index{proto}(sweep, rise_num); 
                        array = rise_index-400:rise_index+400;
                        template = data{proto,ANG}(sweep, array); 
                        signal = data{proto,ANG}(sweep, :); 
                    
                        % Peak inside template
                        [pks, locs] = findpeaks(template, 'MinPeakDistance', 200);
                        locs = locs + array(1);
                        
                        % Find the peak that follow the condition 
                        the_pks = 0; the_loc = 0;  % peaks and locations
                        for i = 1:numel(locs) % loop through locations
                            if pks(i) > signal(locs(i) - 200) && pks(i) > signal(locs(i)+200)
                                the_pks = pks(i);
                                the_loc = locs(i);
                            end 
                        end 
        
                        % Update step_index or throw error
                        if the_pks == 0     % non found: error
                            error(proto,sub,sweep) = 1;                     
                        else                % no error 
                            step_index{proto}(sweep, rise_num) = the_loc;
                        end 
                    end % step
                end % sweep
        
                % Display no-peak idxs 
                temp = find(error(proto,sub,:) == 1);
                if ~isempty(temp)
                    singleStr = string;
                    for i = 1:numel(temp)
                        singleStr = singleStr + num2str(temp(i)) + " "; 
                    end 
                    msg = "\n     No peak found. Subject: " + sub + ". Sweep: " + singleStr +  ". Protocol: " + proto + " "; 
                    fprintf(2,msg); 
                end 
            end % proto

        % Save realigned data 
        total_data{1,1,sub} = data; 
        total_step{1,1,sub} = step_index; % update step_index
        end % exist 
    end % sub
    fprintf('\n     done [ %4.2f sec ] \n', toc);
else 
    fprintf('disable \n');
end  % readjust 
 

if show_gui
    fprintf('script: Re-adjust gui - [Waiting for user input]')
    data = total_data{1,1,gui_subject}; 

    filename = gui_subject+"offset.mat";
    filepath = fullfile(folderpath, filename);
    if exist(filepath, 'file') == 2
        load(filepath) % return 4x1 cell array called 'offset'
        step_index = offset; 
    else
        step_index = total_step{1,1,gui_subject}; % update step_index
    end

    offset = [];    % preparer for new input    
    readjustFSR     % open gui
    pause           % wait for user input 
    
    if ~isempty(offset)
        if exist(filepath, 'file') == 2 
            prompt = newline + "Want to over save. YES: press >y<. NO, press >n<"+ newline;
            correctInput = false; 
            while correctInput == false     % Wait for correct user input
                switch input(prompt, 's')   % Save user input
                    case "y"
                        correctInput = true; 
                        oversave = true; 
                    case "n"
                        correctInput = true; 
                        oversave = false;
                    otherwise
                        correctInput = false;
                        warning("Input not accepted")
                end 
            end 
        else 
            oversave = true; 
        end 

        if oversave
            total_step{1,1,gui_subject} = offset; 
            save(folderpath + gui_subject+"offset",'offset')
            disp("Data saved")
        end         
    end 
    fprintf('gui done \n')
end 


%% Remove saturated data 
fprintf('script: Remove saturated data . . .'); tic

remove_saturated = true;    % enable or disable 
threshold = -10;            % remove ANG data if lower than 
span = [0, 20];             % ms 

%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
if remove_saturated  

    % From ms to samples 
    span = ms2sec(span)*Fs;        % from ms to sample
    exc_ctl = cell(size(names));    % exclude Control
    
    for sub = 1:numel(names) % loop through subjects
        % Load data 
        data = total_data{1,1,sub}; 
        step_index = total_step{1,1,sub};
       
        % Find saturated idxs
        for sweep = 1:size(data{CTL,FSR},1) % loop through sweeps 
            for step = 1:3 % loop through steps 
                [rise] = func_find_edge(steps_tested(step)); 
                edge = step_index{CTL}(sweep,rise);
                y = data{CTL,ANG}(sweep, span(1)+edge:span(2)+edge); 
                if any(find(y<threshold))
                    exc_ctl{sub} = unique([exc_ctl{sub}, sweep]);  
                end
            end 
        end
    
        % Remove saturated idxs
        step_index{CTL}(exc_ctl{sub},:) = []; 
        for i = [SOL, TA, FSR, ANG]
            data{CTL,i}(exc_ctl{sub},:) = []; 
        end 

        % Display which step to remove
        if ~isempty( exc_ctl{sub} )
            msg = "\n     Saturated data. Subject: " + sub + ". Sweep: " + num2str(exc_ctl{sub}) + " "; 
            fprintf(2,msg); 
            
        end 

        % Save data
        total_data{1,1,sub} = data; 
        total_step{1,1,sub} = step_index;
    end
    
    fprintf('\n     done [ %4.2f sec ] \n', toc);
else 
    fprintf('disable \n');
end 

%% Normalize EMG (make as a function instead) 
fprintf('script: Normalize EMG  . . . '); tic; 

normalize = true;      % enable or disable
span = 20;             % how big is the smooth span.
normalizing_step = 0;  % which step is the data being normalized to [0,2,4]?
norm_array_ms = [-800, -200];  % normalize array, denoted in ms                          


%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
if normalize 

    % Normalize prebaseline control and horizontal 
    for sub = 1:length(names) % loop through subjects  
        % Load data 
        data = total_data{1,1,sub};
        step_index = total_step{1,1,sub};

        if ~any(strcmp(names(sub), ["Christian", "Soeren"])) % christian and soeren only completed the prebaseline protocol 
            [data, factor(sub,:)] = func_normalize_EMG(step_index, data, 'protocols', [CTL,VER,HOR],  'normalize_to_step', normalizing_step,'span', span);
        else
            [data] = func_normalize_EMG(step_index, data, 'protocols', CTL,  'normalize_to_step', normalizing_step,'span', span);
        end
        total_data{1,1,sub} = data; % update data
    end

    % Normalize vertical 
    if included_vertical_data_processing
    for sub = 1:numel(names_indiv)
        data = total_data_vertical{1,1,sub}; % load data 
        type = total_type_vertical{1,1,sub}; no = type{2}; yes = type{1};
        x_axis = data{VER,time};
        temp1 = find(floor(norm_array_ms(1)) == x_axis);
        temp2 = find(floor(norm_array_ms(2)) == x_axis); 
        norm_sample = [temp1, temp2(1)]; 
    
        sol_max = max(mean(data{VER,SOL}(no,norm_sample(1):norm_sample(2)),1)); 
        ta_max  = max(mean(data{VER,TA }(no,norm_sample(1):norm_sample(2)),1)); 
        
        for sweep = 1:size(data{VER,SOL},1) % sweep
            data{VER,SOL}(sweep,:) = data{VER,SOL}(sweep,:)/sol_max;
            data{VER,TA }(sweep,:) = data{VER,TA }(sweep,:)/ta_max; 
        end
        total_data_vertical{1,1,sub} = data; % save normalize
    end
    end

    fprintf('done [ %4.2f sec ] \n', toc);
else 
    fprintf('disable \n');
end 


%% Speed and aceleration (make as a function instead) 
fprintf('script: Speed and aceleration . . . '); tic; 

plot_data = false;          % enable or disable plot
span_position = 5;          % inc. sample in guassian filter span 
span_velocity = 5;          % inc. sample in guassian filter span 
span_acceleration = 10;     % inc. sample in gaussian filter span 

% Control and Horizontal trials
for sub = 1:length(names) % subjects
    data = total_data{1,1,sub};  % load data 
    for proto = proto_all % protocols 
    
        % Position 
        data{proto,ANG} = data{proto,ANG}.*4+25; % rescale the signal; 
        pos = data{proto,ANG};
        %data{proto,ANG} = smoothdata(data{proto,ANG}, 2, 'gaussian', span_position);    % gaussian smoothing

        % velocity
        diffs1 = diff(data{proto,ANG}, 1, 2)./(dt*10^3);            % [deg/sample]
        diffs1 = padarray(diffs1, [0 1], 'post');                   % zeropadding           
        data{proto,VEL} = smoothdata(diffs1, 2, 'gaussian', span_velocity);    % gaussian smoothing
        clear diffs1
        
        % acceleration
        diffs2 = diff(data{proto,VEL}, 1, 2)./(dt*10^3);            % [deg/sample^2]
        diffs2 = padarray(diffs2, [0 1], 'post');                   % zeropadding
        data{proto,ACC} = smoothdata(diffs2, 2, 'gaussian', span_acceleration);    % gaussian smoothing
        clear diffs2

        % Need to plot before and after 
        if plot_data == 1 && sub == 1
            step_index = total_step{1,1,sub};
            sweep = 1; dur = 1000; before = 500;
            [rise, ~] = func_find_edge(4);
            rise_index = step_index{CTL}(sweep,rise);
            display_array = rise_index-before:rise_index+dur;

            figure; hold on
            subplot(311)
            plot(display_array, pos(1,display_array),'-o', display_array, data{proto,ANG}(sweep,display_array),'-x')
            legend(["raw", "filtered"])

            subplot(312)
            plot(display_array, diffs1(1,display_array),'-o',display_array, data{proto,VEL}(sweep,display_array),'-x')
            legend(["raw", "filtered"])

            subplot(313)
            plot(display_array, diffs2(1,display_array),'-o', display_array, data{proto,ACC}(sweep,display_array),'-x')
            legend(["raw", "filtered"])

        end
    end 
    total_data{1,1,sub} = data; 
end

if included_vertical_data_processing
% Vertical perturbation
for sub = 1:numel(names_indiv) 
    data = total_data_vertical{1,1,sub};
    for i = 1:size(data{VER,1},1) % sweeps
        
        % Position [d]
        %data{VER,ANG} = data{VER,ANG}.*4+25;                % rescale the signal; 
        
        % Velocity [d/s]
        diffs1 = diff(data{VER,ANG}, 1, 2)./(dt*10^3);      % [deg/sample]
        diffs1 = padarray(diffs1, [0 1], 'post');           % zeropadding       
        data{VER,VEL} = smoothdata(diffs1, 2, 'gaussian', span_velocity);       % gaussian smoothing

        % Acceleration [d/s^2]
        diffs2 = diff(data{VER,VEL}, 1, 2)./(dt*10^3);      % [deg/sample^2]
        diffs2 = padarray(diffs2, [0 1], 'post');           % zeropadding
        data{VER,ACC} = smoothdata(diffs2, 2, 'gaussian', span_acceleration);   % gaussian smoothing

    end
    total_data_vertical{1,1,sub} = data;    
end
end
fprintf('done [ %4.2f sec ] \n', toc);

%% Cross correlation 
fprintf('script: Cross correlation  . . . '); tic

croos_bool = true; 
templ_array = [500:1500];     % template array, denoted in samples
show_cross = false; 
subject = 4; 


if croos_bool && included_vertical_data_processing
    for sub = 1:numel(names_indiv)
        % Load data
        data = total_data_vertical{1,1,sub}; 
        type = total_type_vertical{1,1,sub}; no = type{2}; yes = type{1};
        x_axis = data{VER,time};
    
        % Re-align - cross correlation 
        y_yes =  mean(data{VER,SOL}(yes,:),1); 
        y_no = mean(data{VER,SOL}(no,:),1); 
        template = mean(data{VER,SOL}(no,templ_array),1);
        [rx, lags] = xcorr(y_yes, template);  % Cross-correlation
        
        % Re-align - find Peaks
        [pks, locs] = findpeaks(rescale(rx), 'MinPeakDistance', 500);
        tmp = find(lags(locs) > 0);
        pks = pks(tmp);
        locs = locs(tmp);
        delay = templ_array(1)-lags(locs(1)); % denoted in samples 
        delay_ms = sec2ms(delay*dt);
    
        % Re-align - actual
        for sweep = 1:numel(no)
            for type = [SOL, TA, ANG, VEL]
                data{VER,type}(no(sweep),:) = [data{VER,type}(no(sweep),delay+1:end), zeros(1, delay)];
            end
        end 
        
        % Show cross correlation
        if and(show_cross, sub == subject)
            

            % Check if a figure with the name 'TASK3' is open
            fig = findobj('Name', 'Cross correlation');
            if ~isempty(fig), close(fig); end
        
            figure('name', 'Cross correlation');
            subplot(311); hold on
                plot(templ_array, template, 'color', [0.7, 0.7, 0.7], 'LineWidth', 5 )
                plot(y_no, 'color', "blue", 'LineWidth', 2)
                plot(y_yes, 'color', 'black')
                title("before")
            subplot(312); hold on 
                title("Cross correlation")
                N = numel(y_yes); 
                plot(lags(locs(1)):lags(locs(1))+numel(template)-1, template, 'color', [0.7, 0.7, 0.7], 'LineWidth', 5);
                plot(0:N-1, y_yes, 'color', 'black')
                plot(lags, rescale(rx), 'color', 'blue');
                plot(lags(locs), pks, 'rx', 'linewidth', 1);
                plot(lags(locs(1)), pks(1), 'o');
                plot([lags(locs(1)), lags(locs(1))], [0,pks(1) ])
            subplot(313); hold on
                title("After")
                plot(mean(data{VER,SOL}(no,:),1), 'color', "blue", 'LineWidth', 2)
                plot(mean(data{VER,SOL}(yes ,:),1), 'color', 'black', 'LineWidth', 1)
        end

        % Save data
        total_data_vertical{1,1,sub} = data; 
    end 
    fprintf('done [ %4.2f sec ] \n', toc);
else 
    fprintf('disable \n');
end

%% Weighted data 
fprintf('script: weighting_data  . . . '); tic

weighting_data = true; 

if weighting_data
    
    % Find the subject with smallest subject size
    threshold = 50; 
    for sub = 1:numel(names)
        data = total_data{1,1,sub}; 
        sub_size = size(data{CTL,ANG},1); % sweep size 
        if threshold > sub_size; threshold = sub_size; end 
    end 
    
    % Remove sweeps larger than smallest subject size
    for sub = 1:numel(names)
        data = total_data{1,1,sub};         % load data
        step_index = total_step{1,1,sub};   % load data 
        sub_size = size(data{CTL,ANG},1);   % sweep size 
        if sub_size > threshold 
            step_index{CTL}(threshold+1:end,:) = []; 
            for i = [SOL, TA, FSR, ANG]
                data{CTL,i}(threshold+1:end,:) = []; 
            end 
        end
        total_data{1,1,sub} = data;         % save data
        total_step{1,1,sub} = step_index;   % save data
    end 
    fprintf('done [ %4.2f sec ] \n', toc);
else 
    fprintf('disable \n');
end


%% Task 0.1 Simplify the matlab script
% Make the script accessible to be navigated by Andrew and Thomas. 
% - clearify parameters meant to be adjusted. 
% - make passive code as function and remove.

%% Task 0.2 Show average sweep for single subject
fprintf('script: TASK 0.2  . . . ');

show_plot = false;      % Disable or enable plot
subject = 10;            % Obtions: 1:8
proto = CTL;            % Obtions: CTL, VER, HOR 
str_sen = ["Position", "Soleus", "Tibialis"];    % Obtions: "Soleus", "Tibialis","Position", "Velocity", "Acceleration"; 
show_FSR = true; 

align_bool = true;      % Should the data be aligned with step specified in "Align with specific Stair step"
    alignWithStep = align_with_obtions(1) ;
    before = 200; 
    after = 100; 

% .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
if show_plot
fprintf(' plot subject: >> ' + names(subject) + ' << \n' );

if align_bool
    % Load data and align with defined step 
    data = total_data{1,1,subject}; 
    step_index = total_step{1,1,subject};
    temp = cell(3,7); 
    [temp{proto,:}] = func_align(step_index{proto}, data{proto,[1:4,6:7]}, 'sec_before', ms2sec(before), 'sec_after', ms2sec(after), 'alignStep', alignWithStep);
    clear data
    data = temp;
    x_axis = data{proto,time};
    x_axis = sec2ms(x_axis);
    str_xlabel = "Time [ms]" + newline + "Data normalized to step four"; 
else 
    % Load data 
    data = total_data{1,1,subject}; 
    x_axis = linspace(-4, 6-dt, N); 
    x_axis = sec2ms(x_axis); 
    str_xlabel = "Time [ms]" + newline + "Data normalized to Force-Platform";
end 

switch proto
    case HOR
        type = total_type{:,:,subject};
        yes = type{3}; no = type{4}; str_title = "Horizontal perturbation"; 
    case VER
        type = total_type{:,:,subject};
        yes = type{1}; no = type{2}; str_title = "Vertical perturbation"; 
    case {CTL}
        str_title = "Pre-baseline Control";
end

figure; 
    sgtitle(str_title + " - subject " + names(subject)); 
    for i = 1:size(str_sen,2) % check and plot data included in str_sen
        switch str_sen(i) 
            case "Soleus"
                sensor_modality = SOL; 
                str_ylabel = "Soleus" + newline + "[\muV]"; 
            case "Tibialis"
                sensor_modality = TA; 
                str_ylabel = "Tibialis"+newline+"[\muV]"; 
            case "Position"
                sensor_modality = ANG;
                str_ylabel = "Position" + newline + "[Deg]" + newline + "[Dorsal] <  > [Plantar]"; 
            case "Velocity"
                sensor_modality = VEL; 
                str_ylabel = "Velocity" + newline + "[Deg/s]"; 
            case "Acceleration"
                sensor_modality = ACC; 
                str_ylabel = "Acceleration " + newline + "[Deg/s^2]"; 
             otherwise
                disp("ERROR" + newline + "String: >>" + str_sen(i) + "<< is not registered.")
        end
        
        switch proto
            case {VER, HOR} 
                subplot(size(str_sen,2)*100 + 10 + i); hold on; ylabel(str_ylabel); 
                plot(x_axis, mean(data{proto,sensor_modality}(no,:),1), "LineWidth",3, "color",[0.75, 0.75, 0.75])
                plot(x_axis, mean(data{proto,sensor_modality}(yes,:),1), "LineWidth",1, "color","black")

                if show_FSR
                    y_fsr = rescale(mean(data{proto,FSR},1)); 
                    yyaxis right; ylabel("Phase"); ylim([-0.1 1.1])
                    plot(x_axis, y_fsr, "color",	"yellow");
                end
                
            case {CTL, CTL2}
                subplot(size(str_sen,2)*100 + 10 + i); hold on; ylabel(str_ylabel); 
                % plt std around mean 
                y = mean(data{proto,sensor_modality},1); 
                std_dev = std(data{proto,sensor_modality});
                curve1 = y + std_dev;
                curve2 = y - std_dev;
                x2 = [x_axis, fliplr(x_axis)];
                inBetween = [curve1, fliplr(curve2)];
                fill(x2, inBetween, [0.75, 0.75, 0.75], 'LineStyle','none'); 
                plot(x_axis, y, 'LineWidth', 2, "color","black"); 

                if show_FSR % show FSR if enabled 
                    y_fsr = rescale(mean(data{proto,FSR},1)); 
                    yyaxis right; ylabel("Phase"); ylim([-0.1 1.1])
                    plot(x_axis, y_fsr, "color",	"yellow");
                end
        end
        if i == size(str_sen,2)
            xlabel(str_xlabel)
        end 
    end

    clear y_fsr
else 
    fprintf('disable \n');
end 


%% Task 0.3 Show individual sweep for single subject
% undersøg for metodisk fejl.
fprintf('script: TASK 0.3  . . . ');

show_plot = false;       % Disable or enable plot
subject = 10;           % Obtions: 1:9
proto = CTL;            % Obtions: CTL
sensor_modality = SOL;  % Obtions: SOL, TA, ANG, VEL, ACC
before = 50;            % before foot strike included in ms
after = 0;              % after foot lift-off included in ms

% .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
if show_plot
fprintf('plot subject: >> ' + names(subject) + ' << \n' );
data = total_data{1,1,subject}; 
step_index = total_step{1,1,subject};
x_axis_total = linspace(-4, 6-dt, N); % time axis 
sweepNum = size(data{proto,ANG},1);   % total sweep size


figure('name','control sweep'); % Begin plot
    loop = true; sweep = 1; 
    while loop == true
        clc % clear cmd promt 
        sgtitle("Sweep: " + sweep) % display current sweep in promt

        subplot(211);  
        % plot data 
        yyaxis left;
        plot(x_axis_total, mean(data{proto,sensor_modality},1), '-', "LineWidth",3, "color",[0.75, 0.75, 0.75]) % mean plt 
        hold on 
        plot(x_axis_total, data{proto,sensor_modality}(sweep,:), '-', "LineWidth",1, "color","black") % sweep plt 
        hold off
      
        % plt formalia 
        xlabel("Time"+newline+"[sec]")
        ylabel(labels_ms(sensor_modality))
        title(['Black graph, Sweep data. {\color{gray} Gray graph, Mean data [n=' num2str(sweepNum) '].}'])

        if show_FSR
            y_fsr = rescale(data{proto,FSR}(sweep,:)); 
            yyaxis right; ylabel("Phase"); ylim([-0.1 1.1]); 
            plot(x_axis_total,y_fsr, "color",	"red"); 
        end
    
        % Define the data for each step 
        clear y
        for k = 1:3
            clear data_align
            data_align = cell(3,7); 
            [data_align{proto,:}] = func_align(step_index{proto}, data{proto,[1:4,6:7]}, 'sec_before', ms2sec(before), 'sec_after', ms2sec(after), 'alignStep', align_with_obtions(k));
            x_axis = data_align{proto,time};
            y{k,2} = sec2ms(x_axis);
            y{k,1} = data_align{proto,sensor_modality}(sweep,:); 
            y{k,3} = mean(data_align{proto,sensor_modality},1);
        end 
    
        % plot data for each step 
        for k = 1:3 % loop through steps
            subplot(233+k); hold on; 
            if sensor_modality == or(SOL,TA)
                ylim([0 ceil(max([max(y{1,1}),  max(y{2,1}), max(y{3,1})])/100)*100])
            end
            plot(y{k,2}, y{k,3}, "LineWidth",2, "color", [0.75, 0.75, 0.75]) % Mean
            plot(y{k,2}, y{k,1}, "LineWidth",1, "color","black") % Sweep
            ylim auto
            YL = get(gca, 'YLim'); ylim([YL(1) YL(2)]);
            plot([0, 0],[YL(1) YL(2)], "REPLACE_WITH_DASH_DASH","LineWidth",1, "Color", "red") % plt fsr 
    
            % plt formalia 
            xlabel("Time"+newline+"[ms]")
            title("Step: " + steps_tested(k))
            ylabel(labels_ms(sensor_modality))
        end

        % Wait for user input
        correctInput = false; 
        prompt = "Continue, press >c<" + newline + "Quite, press >q<"+ newline + "Change sweep number, press >t<"+ newline;    
        while correctInput == false     % Wait for correct user input
            str = input(prompt, 's');   % Save user input
            if strcmp(str,"q")          % If pressed - Quite the loop 
                disp("Loop stopped")
                loop = false; correctInput = true; 
                fig = findobj('Name', 'control sweep');
                if ~isempty(fig), close(fig); end
            elseif strcmp(str,"t")      % If pressed - Change sweep number
                sweep = input("New sweep number: ")-1; 
                correctInput = true; 
            elseif strcmp(str,"c")      % If pressed - Continue to next sweep
                correctInput = true; 
            end 
    
            if correctInput == false
                warning("Input not accepted")
            end
        end
        sweep = sweep + 1; % Continue to next sweep
        if sweep > size(data{proto,sensor_modality},1) % stop loop if max sweep reached
            loop = false; 
        end 
    end
else 
    fprintf('disable');
end 





%% Task 1.1 FC correlation with EMG (Seperate steps, Single subject) 
% Find individuelle outliner og undersøg for refleks response. 
fprintf('\nscript: TASK 1.1  . . . '); tic

show_plot = false;           % plot the following figures for this task
subject = 4;                % subject to analyse
protocol = CTL;                % Only works for pre and post baseline trials
before = 200; 
after = 50;
xlimits = [-before 300];
savepgn = false; 
inc_sub = [1,2,3,4,5,7,8,9,10]; % Exclude sub 6 

% .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .

% General search bars: 
dep_off = 39; dep_len = 20; 
step = 2; predict_search(step,:) = [0,20]; depend_search(step,:) = [predict_search(step,1)+dep_off,predict_search(step,1)+dep_off+dep_len];    % ms 
step = 4; predict_search(step,:) = [0,20]; depend_search(step,:) = [predict_search(step,1)+dep_off,predict_search(step,1)+dep_off+dep_len];    % ms 
step = 6; predict_search(step,:) = [0,20]; depend_search(step,:) = [predict_search(step,1)+dep_off,predict_search(step,1)+dep_off+dep_len];    % ms 

% Preallocation
predictor_value = cell(size(names)); 
depended_value = cell(size(names)); 
    
for sub = inc_sub   % loop through subjects
    if ~readjust    % readjust disabled. Manuel search-bars applied
        switch sub 
        case 1
            predict_search(2,:) = [1.5,1.5+20];  depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [-0.5,20-0.5]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [-2,20-2];     depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    % ms 
        case 2
            predict_search(2,:) = [-12,20-12];   depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [3,20-3];      depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];  % ms 
            predict_search(6,:) = [-4.5,20-4.5]; depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_off];   % ms 
        case 3
            predict_search(2,:) = [0.5, 20+0.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];   % ms 
            predict_search(4,:) = [1.5, 1.5+20]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [3, 3+20];     depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];   % ms 
        case 4
            predict_search(2,:) = [-4.5, 20-4.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [-5.5, 20-5.5]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [-6.5, 20-6.5]; depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    % ms 
        case 5
            predict_search(2,:) = [2, 2+20];      depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];   % ms 
            predict_search(4,:) = [2.5, 2.5+20];  depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [2.5, 2.5+20];  depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];   % ms 
        case 6 
            predict_search(2,:) = [-2, 18];       depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [1, 21];        depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [0, 20];        depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    % ms 
        case 7
            predict_search(2,:) = [-13.5, 20-13.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [-15.5, 20-15.5]; depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [-20.5, -0.5]; depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];   % ms 
        case 8
            predict_search(2,:) = [-20,0];        depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [-9.5,20-9.5];  depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [-9.5,20-9.5];  depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    % ms  
        case 9
            predict_search(2,:) = [-53.5,20-53.5]; depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [-7,20-7];       depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [-41,20-41];     depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    % ms  
        case 10
            predict_search(2,:) = [-69,20-69];     depend_search(2,:) = [predict_search(2,1)+dep_off,predict_search(2,1)+dep_off+dep_len];    % ms 
            predict_search(4,:) = [-56,20-56];     depend_search(4,:) = [predict_search(4,1)+dep_off,predict_search(4,1)+dep_off+dep_len];    % ms 
            predict_search(6,:) = [-61,20-61];      depend_search(6,:) = [predict_search(6,1)+dep_off,predict_search(6,1)+dep_off+dep_len];    % ms  
        end 
    end %readjust
 
    % Remember values for later plt
    if sub == subject 
        predict_search_plt = predict_search; 
        depend_search_plt = depend_search; 
    end
    
    % Load data from defined subject defined by loop
    data = total_data{1,1,sub};  
    step_index = total_step{1,1,sub};
        
    % Find predictor and depended 
    for k = 1:3                      
        step = steps_tested(k);
       
        [rise, fall] = func_find_edge(step);                    % rise and fall value for the given step
        falling = []; falling = step_index{protocol}(:,fall);   % fall indexes for all sweeps
        rising  = []; rising  = step_index{protocol}(:,rise);   % rise indexes for all sweeps
        
        step_sec{sub}(k,:) = (falling(:) - rising(:))*dt;        % duration of each step phase, unit [sec]

        % Re-define window ms to sample
        predict_search_index = floor(ms2sec(predict_search(step,:))*Fs);  % unit [sample]
        depend_search_index  = floor(ms2sec(depend_search(step,:))*Fs);   % unit [sample]

        for sweep = 1:size(data{protocol,1},1)     
                       

            % Find rise index for the given step and define window 
            rise_index = step_index{protocol}(sweep,rise);
            predict_search_array = []; predict_search_array = predict_search_index(1)+rise_index : predict_search_index(2)+rise_index; 
            depend_search_array  = []; depend_search_array = depend_search_index(1)+rise_index : depend_search_index(2)+rise_index; 
          

            % PREDICTOR VALUES:
            ang_data = rescale(data{protocol,ANG}((sweep),:)); 
            %predictor_value{sub}(step,sweep) = mean(data{protocol,ANG}((sweep), predict_search_array),2); 
            %predictor_value{sub}(step, sweep) = (data{protocol,ANG}((sweep),predict_search_array(1)) - data{protocol,ANG}((sweep),predict_search_array(end))) / diff(predict_search(step,:)); 
            %predictor_value{sub}(step,sweep) =  mean(ang_data(predict_search_array)); 
            predictor_value{sub}(step,sweep) =  (ang_data(predict_search_array(1)) - ang_data(predict_search_array(end))) / diff(predict_search(step,:));
            
            % DEPENDED VALUES 
            for EMG = [SOL, TA]
                EMG_data = (data{protocol,EMG}((sweep),:)); 

                step_EMG{sub}(EMG,k,sweep) = mean(EMG_data( [rising(sweep):falling(sweep)] ));  % EMG activity for the whole standphase 
                depended_value{sub}(EMG, step, sweep) =  max(EMG_data(depend_search_array)) - mean(EMG_data(depend_search_array));
                %depended_value{sub}(sensory_type, step, sweep) = mean(data{protocol,sensory_type}((sweep), depend_search_array),2);
            end
        end %sweep
    end %step 
end 


if show_plot
    if ~readjust
        msg = "Be Aware: Data re-adjustment is disabled. Manuel defined search-bars applied . . . "; 
        fprintf(2,msg); 
    else 
        fprintf(' Data re-adjustment enabled. General search bar applied . . .')
    end
       
    % Load data for plot, defined by >> subject <<
    data = total_data{1,1,subject};  
    step_index = total_step{1,1,subject};
    
    % Plot figure
    fig = findobj('Name', 'Pre-baseline');
    if ~isempty(fig), close(fig); end
    figSize = [50 50 width-200 height-200]; % where to plt and size
    figure('Name', 'Pre-baseline','Position', figSize); % begin plot 
    sgtitle("TASK 1.1 Data: Prebaseline. Subject: " + subject + ". [n = " + size(data{protocol,1},1) + "]."); 

    % Patch properties 
    y_pat = [-1000 -1000 1000 1000];
    patchcolor = "blue"; 
    FaceAlpha = 0.4; 
    
    for k = 1:3 % loop through steps       
        x_pat_pre = [predict_search_plt(steps_tested(k),1) predict_search_plt(steps_tested(k),2) predict_search_plt(steps_tested(k),2) predict_search_plt(steps_tested(k),1)];
        x_pat_dep = [depend_search_plt(steps_tested(k),1) depend_search_plt(steps_tested(k),2) depend_search_plt(steps_tested(k),2) depend_search_plt(steps_tested(k),1)];
    
        data_plot = cell(3,7); 
        [data_plot{protocol,:}] = func_align(step_index{protocol}, data{protocol,[1:4,6:7]}, 'sec_before', ms2sec(before), 'sec_after', ms2sec(after), 'alignStep', align_with_obtions(k));
        
        % Predictor 
        sensor_type = [ANG, VEL]; % Ankle and velocity
        for i = 1:numel(sensor_type)
            subplot(4,3,0+k + (i-1)*3); hold on; % Ankel 
            % Formalia setup
            ylabel("Position");
            title("Step " + k*2)
            subtitle("Ankel" +" "+ predict_search_plt(steps_tested(k),1) + " : "+predict_search_plt(steps_tested(k),2)+"ms")
            xlim(xlimits)

            % Plt data 
            y = mean(data_plot{protocol,sensor_type(i)},1); 
            std_dev = std(data_plot{protocol,sensor_type(i)});
            curve1 = y + std_dev;
            curve2 = y - std_dev;
            x_axis = data_plot{protocol,time};
            x_axis = sec2ms(x_axis);
            x2 = [x_axis, fliplr(x_axis)];
            inBetween = [curve1, fliplr(curve2)];   
            fill(x2, inBetween, [0.75, 0.75, 0.75], 'LineStyle','none'); 
            plot(x_axis, y, 'LineWidth', 2, "color","black"); 
            YL = get(gca, 'YLim'); ylim([YL(1) YL(2)]);
            patch(x_pat_pre,y_pat,patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', "none")
        end 

        % Depended
        sensor_type = [SOL, TA]; % Soleus and Tibialis
        for i = 1:numel(sensor_type)
            subplot(4,3, 6+k+(i-1)*3); hold on; 
            % Formalia setup
            ylabel(labels_ms(sensor_type(i))); 
            subtitle(labels(sensor_type(i)) +" "+ depend_search_plt(steps_tested(k),1) + " : "+depend_search_plt(steps_tested(k),2)+"ms")            
            xlim(xlimits)
    
            % Plt data 
            y = mean(data_plot{protocol,sensor_type(i)},1); 
            std_dev = std(data_plot{protocol,sensor_type(i)});
            curve1 = y + std_dev;
            curve2 = y - std_dev;
            x_axis = data_plot{protocol,time};
            x_axis = sec2ms(x_axis);
            x2 = [x_axis, fliplr(x_axis)];
            inBetween = [curve1, fliplr(curve2)];   
            fill(x2, inBetween, [0.75, 0.75, 0.75], 'LineStyle','none'); 
            plot(x_axis, y, 'LineWidth', 2, "color","black"); 
            YL = get(gca, 'YLim'); ylim([YL(1) YL(2)]);
            patch(x_pat_dep,y_pat,patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', "none")
        end   
    end 
    % Define the file name and path to save the PNG file
    filename = "Subject"+subject+".png";
    filepath = 'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/task1 - control step regresion/non-readjusted and all samples/';
    fullpath = fullfile(filepath, filename);
    if savepgn
        saveas(gcf, fullpath, 'png'); 
    end


% ====================================

    % begin plot
    fig = findobj('Name', 'Pre-baseline2');
    if ~isempty(fig), close(fig); end
    screensize = get(0,'ScreenSize');
    figSize = [100 100 width-200 height-200]; % where to plt and size
    figure('Position',figSize,'Name', 'Pre-baseline2'); 

    marker = ["*",".","x"];    
    sgtitle("Single subject [sub="+ subject +"]. Weighted: "+weighting_data+". Re-align: " + readjust)

    sensory_type = [SOL, TA]; 
    for i = 1:numel(sensory_type)
        depended = []; predictor = [];  
        for k = 1:3   
            subplot(2,5,k+(i-1)*5 ); hold on
                if k == 1; ylabel(labels(sensory_type(i))); end
                de = []; de = nonzeros(squeeze(depended_value{subject}(sensory_type(i), steps_tested(k),:))); 
                pr = []; pr = nonzeros(squeeze(predictor_value{subject}(steps_tested(k),:)));
                mdl = fitlm(pr, de);
                b = table2array(mdl.Coefficients(1,1)); 
                a = table2array(mdl.Coefficients(2,1)); 
                p_value = round(table2array(mdl.Coefficients(2,4)), 3);
                r2 = round(mdl.Rsquared.Adjusted, 3);
                linearReg = @(x) x*a + b;     
                plot(pr, de, marker(k), "color", "blue")          
                plot(pr, linearReg(pr), "color", "red")
                if p_value < 0.05
                    subtitle(['P-value: {\color{black} ' num2str(p_value) '}. R^2' num2str(r2)])
                else 
                    subtitle(['P-value: {\color{red} ' num2str(p_value) '}. R^2' num2str(r2)])
                end
                title("Step " + steps_tested(k))

            subplot(2,5,4+5*(i-1):5+5*(i-1)); hold on
                depended(k,:) = nonzeros(squeeze(depended_value{subject}(sensory_type(i), steps_tested(k),:))); 
                predictor(k,:) = nonzeros(squeeze(predictor_value{subject}(steps_tested(k),:)));
                plot(predictor(k,:), depended(k,:), marker(k), "color", "blue")
        end
        
        % Linear regression 
        depended_all_step = [depended(1,:) depended(2,:) depended(3,:)];
        predictor_all_step = [predictor(1,:) predictor(2,:) predictor(3,:)];
        mdl = fitlm(predictor_all_step, depended_all_step);  
        b = table2array(mdl.Coefficients(1,1)); 
        a = table2array(mdl.Coefficients(2,1));
        p_value =  table2array(mdl.Coefficients(2,4)); 
        r2 = round(mdl.Rsquared.Adjusted, 3); 
        linearReg = @(x) x*a + b; 
        plot(predictor_all_step, linearReg(predictor_all_step), "color", "red")
        title("All Step ")

        
        % Plt formalia 
        legend(["Data: Step 2", "Data: Step 4", "Data: Step 6","Fit"])
        if p_value < 0.05
            subtitle(['P-value: {\color{black} ' num2str(p_value) '}. R^2' num2str(r2)])
        else 
            subtitle(['P-value: {\color{red} ' num2str(p_value) '}. R^2' num2str(r2)])
        end
    end 

    % Set y-limits and x-limits on all subplots 
    ax = findobj(gcf, 'type', 'axes');
    ylims = get(ax, 'YLim'); 
    xlims = get(ax, 'XLim'); 
    [~, idx_y_ta]  = max(cellfun(@(x) diff(x), ylims(1:4)));
    [~, idx_y_sol] = max(cellfun(@(x) diff(x), ylims(5:8)));
    [~, idx_x_ta]  = max(cellfun(@(x) diff(x), xlims(1:4)));
    [~, idx_x_sol] = max(cellfun(@(x) diff(x), xlims(5:8)));
    idx_y_sol = idx_y_sol+4; 
    idx_x_sol = idx_x_sol+4; 
    for i = 1:numel(ax)
        if any(i == 1:4)
            set(ax(i), 'YLim', ylims{idx_y_ta})
            set(ax(i), 'XLim', xlims{idx_x_ta})
        elseif any(i == 5:8)  
            set(ax(i), 'YLim', ylims{idx_y_sol})
            set(ax(i), 'XLim', xlims{idx_x_sol})
        end
    end

    % Save as PNG
    filename = "All steps. Subject"+subject+".png";
    % filepath = 'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/task1 - control step regresion/readjusted and all samples/';
    fullpath = fullfile(filepath, filename);
    if savepgn; saveas(gcf, fullpath, 'png'); end

    fprintf('done [ %4.2f sec ] \n', toc);
else
    fprintf('disable \n');
end


%% Task 1.2 FC correlation with EMG (Assemble steps) 
fprintf('script: TASK 1.2  . . . '); tic
show_plot = false; 

%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
if show_plot
    reg_data = struct; 
    marker = ["*",".","x"];    

    % Re-arrange data from cell to struct. 
    data_reg = struct; 
    data_reg.dep_steps = cell(2,3);     % depended sortet each step,  [sol,ta]
    data_reg.pre_steps = cell(1,3);     % predictor sortet each step, [vel]
    data_reg.pre = [];                  % depended sortet all step,   [sol,ta]
    data_reg.dep = cell(2,1);           % predictor sortet all step,  [vel]

    % Re-arrange data from cell to array and save in struct
    for sub = inc_sub
        for step = 1:3 
            for EMG = [SOL,TA]
                data_reg.dep_steps{EMG,step} = [data_reg.dep_steps{EMG,step}, nonzeros(squeeze(depended_value{sub}(EMG, steps_tested(step),:)))' ]; 
                data_reg.dep{EMG} = [data_reg.dep{EMG}, nonzeros(squeeze(depended_value{sub}(EMG, steps_tested(step),:)))' ];
            end
            data_reg.pre = [data_reg.pre,  nonzeros(squeeze(predictor_value{sub}(steps_tested(step),:)))'];
            data_reg.pre_steps{step} = [data_reg.pre_steps{step}, nonzeros(squeeze(predictor_value{sub}(steps_tested(step),:)))'];
        end 
    end 

    % Defining plt window size
    figSize = [100 100 width-200 height-200]; % where to plt and size
    fig = findobj('Name', 'Pre-baseline all subject');
    if ~isempty(fig), close(fig); end
    figure('Name','Pre-baseline all subject','Position', figSize); % begin plot 
    sgtitle("Correlation [n="+numel(inc_sub)+"]. Weighted: "+weighting_data+". Re-align: " + readjust)
    
    
    % Plot subject data in different colors 
    for sub = inc_sub % subject
        for sensory_type = [SOL,TA] % muscle type
            depended = []; predictor = [];  
            for k = 1:3 % loop steps 
                depended(k,:) = nonzeros(squeeze(depended_value{sub}(sensory_type, steps_tested(k),:))); 
                predictor(k,:) = nonzeros(squeeze(predictor_value{sub}(steps_tested(k),:)));
                
                % Remember p-value and slope for later plot
                mdl = fitlm(predictor(k,:), depended(k,:));  
                reg_data.slopes(sub, sensory_type, k) = table2array(mdl.Coefficients(2,1));   % slopes
                reg_data.p_value(sub, sensory_type, k) = table2array(mdl.Coefficients(2,4));  % p_values

                % Plt the individuel steps
                subplot(2, 5, 5*(sensory_type-1)+k); hold on; % 5*(s-1)+k={1,2,3,6,7,8}, k={1,2,3}, s={1,2}            
                plot(predictor(k,:), depended(k,:),'x');
                title("Step " + steps_tested(k))
                xlabel("Pos(s-e)/w")
                ylabel(labels(sensory_type))
            end

            % Plt the combined steps 
            subplot(2,5, 4+5*(sensory_type-1):5+5*(sensory_type-1)); hold on % 4+5*(s-1)={4,9}, 5+5*(s-1)={5,10} s={1,2}
            plot(predictor(:)', depended(:)','x')
            title("All steps")            
            ylabel(labels(sensory_type))
            xlabel("Pos(s-e)/w")

            % Remember p-value and slope for later plot
            mdl = fitlm(predictor(:), depended(:));   
            reg_data.slopes(sub, sensory_type, 4)  = table2array(mdl.Coefficients(2,1));  % slopes
            reg_data.p_value(sub, sensory_type, 4) = table2array(mdl.Coefficients(2,4));  % p_values
        end
    end 

    % Set y-limits and x-limits on all subplots 
    ax = findobj(gcf, 'type', 'axes');
    ylims = get(ax, 'YLim'); 
    xlims = get(ax, 'XLim'); 
    [~, idx_y_ta]  = max(cellfun(@(x) diff(x), ylims(1:4)));
    [~, idx_y_sol] = max(cellfun(@(x) diff(x), ylims(5:8)));
    [~, idx_x_ta]  = max(cellfun(@(x) diff(x), xlims(1:4)));
    [~, idx_x_sol] = max(cellfun(@(x) diff(x), xlims(5:8)));
    idx_y_sol = idx_y_sol+4; 
    idx_x_sol = idx_x_sol+4; 
    for i = 1:numel(ax)
        if any(i == 1:4)
            set(ax(i), 'YLim', ylims{idx_y_ta})
            set(ax(i), 'XLim', xlims{idx_x_ta})
        elseif any(i == 5:8)  
            set(ax(i), 'YLim', ylims{idx_y_sol})
            set(ax(i), 'XLim', xlims{idx_x_sol})
        end
    end
    
    % Plot regression 
    for sensory_type = [SOL,TA] % loop 
        for step = 1:3 % loop steps  
            mdl = fitlm(data_reg.pre_steps{step}, data_reg.dep_steps{sensory_type, step}); 
            b = table2array(mdl.Coefficients(1,1)); 
            a = table2array(mdl.Coefficients(2,1)); 
            p_value = table2array(mdl.Coefficients(2,4)); 
            r2 = round(mdl.Rsquared.Adjusted,3); 
            linearReg = @(x) x*a + b; 
            subplot(2, 5, 5*(sensory_type-1)+step); hold on; 
            plot(data_reg.pre_steps{step}, linearReg(data_reg.pre_steps{step}), "color", "red")
            if p_value < 0.05
                subtitle(['P-value: {\color{black} ' num2str(p_value) '}. R^2' num2str(r2)])
            else 
                subtitle(['P-value: {\color{red} ' num2str(p_value) '}. R^2' num2str(r2)])
            end           
        end
        mdl = fitlm(data_reg.pre, data_reg.dep{sensory_type}); 
        b = table2array(mdl.Coefficients(1,1)); 
        a = table2array(mdl.Coefficients(2,1)); 
        p_value = table2array(mdl.Coefficients(2,4)); 
        r2 = round(mdl.Rsquared.Adjusted,3); 
        linearReg = @(x) x*a + b; 
        subplot(2,5, 4+5*(sensory_type-1):5+5*(sensory_type-1)); hold on
        plot(data_reg.pre_steps{step}, linearReg(data_reg.pre_steps{step}), "color", "red")
        if p_value < 0.05
            subtitle(['P-value: {\color{black} ' num2str(p_value) '}. R^2' num2str(r2)])
        else 
            subtitle(['P-value: {\color{red} ' num2str(p_value) '}. R^2' num2str(r2)])
        end   
    end

    % Save as PNG
    filename = "All subject (1-"+numel(names)+").png";
    fullpath = fullfile(filepath, filename);
    if savepgn; saveas(gcf, fullpath, 'png'); end
    
    fprintf('done [ %4.2f sec ] \n', toc);
else
    fprintf('disable \n');
end

%% Task 1.3 FC correlation with EMG (slopes)
% Find the best parameters for one subject and apply them to the other
%    subjects. 
% one factor anova


pltShow = false; 
savepgn = false; 


if pltShow 
    if exist("reg_data")
        figSize = [300 250 700 400]; % where to plt and size

        % Check if a figure with the name 'TASK3' is open
        fig = findobj('Name', 'slopes');
        % If a figure is found, close it
        if ~isempty(fig), close(fig); end

        figure('name','slopes','Position', figSize); % begin plot 
        hold on 
        sgtitle("Correlations slopes [sub="+numel(inc_sub)+"]. Weighted: "+weighting_data+". Re-align: " + readjust)
        
        for sensory_type = [SOL, TA]
            for step = 1:4
                if step == 4
                    subplot(1,5,4:5); hold on 
                    title("All steps")
                else
                    subplot(1,5,step); hold on
                    title("Step " + step)
                end
                slopes  = reg_data.slopes(inc_sub, sensory_type, step); 
                p_value = reg_data.p_value(inc_sub,sensory_type, step);
                x_value = ones(1,size(slopes,1)); 
                if sensory_type == TA; x_value=x_value+1; end 
                
                plot([0 3],[0 0], 'color', 'black')
                plot(x_value(1), mean(slopes), "_", 'Color', 'red', 'linewidth', 4)
                plot(x_value, slopes, '.', 'color', 'black') % soleus data indiv
                for i = 1:length(p_value)
                    if p_value(i) < 0.05 
                        plot(x_value, slopes(i), 'o', 'linewidth',2, 'color', [0.75,0.75,0.75]) % soleus data indiv
                    end 
                end 
                xticks([1 2]);
                xticklabels({'SOL', 'TA'});
                grid on;
    
                if step == 1
                    ylabel("Regression Slopes"+newline+" [ \alpha ]")
                elseif step == 4
                    legend(["", "Group mean", "Slope (subject)", "< 0.05"])
                end
    
            end 
        end
    
        % Set y-limits on all subplots 
        ax = findobj(gcf, 'type', 'axes');
        ylims = get(ax, 'YLim'); 
        max_value = max(cellfun(@max, ylims));
        min_value = min(cellfun(@min, ylims));
        for i = 1:numel(ax)
            set(ax(i), 'YLim', ([min_value max_value]))
        end 
    else 
        msg = "\n     Need to run 'Task 1.2' before to enable this section to plot \n"; 
        fprintf(2,msg); 
    end
    a = num2str(weighting_data) ; 
    b = num2str(readjust); 

    filename = ['Correlations slopes [sub=' num2str(numel(inc_sub)) ']. Weighted ' num2str(weighting_data) ' . Re-align ' num2str(readjust) '.png'];
    filepath = 'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/task1 - control step regresion/slopes/';
    fullpath = fullfile(filepath, filename);
    if savepgn; saveas(gcf, fullpath, 'png'); end
end

%% Speed vs EMG
fprintf('script: TASK 1.4 Speed  . . . '); tic

show_plot_speed = true; 
EMG_compl_step = true; 

%   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .

% step_ms{sub}(k,:) = (falling(:) - rising(:))*dt;        % duration of each step phase, unit [sec]
% step_EMG{sub}(EMG,k,sweep) = mean(EMG_data( [rising(sweep):falling(sweep)] ));  % EMG activity for the whole standphase 
% depended_value{sub}(EMG, step, sweep) =  max(EMG_data(depend_search_array)) - mean(EMG_data(depend_search_array));

if show_plot_speed

    % Re-arrange data from cell to struct. 
    speed_reg = struct;
    speed_reg.pre_steps = cell(1,3);     % predictor sortet each step, [time]
    speed_reg.pre = [];                  % predictor sortet all step,  [time]
    speed_reg.dep = cell(2,1);           % depended sortet all step,   [sol,ta]
    speed_reg.dep_steps = cell(2,3);     % depended sortet each step,  [sol,ta]

    % Re-arrange data from cell to array and save in struct
    for sub = inc_sub
        for s = 1:3
            EMG = [SOL,TA]; 
            for e = 1:numel(EMG)    
                if EMG_compl_step == true
                    step = steps_tested(s); 
                    speed_reg.dep_steps{e,s} = [speed_reg.dep_steps{e,s}, squeeze(step_EMG{sub}(EMG(e),s,:))' ]; 
                    speed_reg.dep{e}         = [speed_reg.dep{e}        , squeeze(step_EMG{sub}(EMG(e),s,:))' ];
                else 
                    data_reg.dep_steps{e,s} = [data_reg.dep_steps{e,s}, squeeze(depended_value{sub}(EMG(e),step,:))' ]; 
                    data_reg.dep{e}         = [data_reg.dep{e}        , squeeze(depended_value{sub}(EMG(e),step,:))' ];
                end 
            end
            speed_reg.pre          = [speed_reg.pre         , squeeze(step_EMG{sub}(EMG(e),s,:))];
            speed_reg.pre_steps{s} = [speed_reg.pre_steps{s}, squeeze(step_EMG{sub}(EMG(e),s,:))'];
        end 
    end 


    % Begin plot
    fig = findobj('Name', 'Speed');
    if ~isempty(fig), close(fig); end
    figure('name','Speed'); % begin plot 
    
    for sub = inc_sub  % subject
        EMG = [SOL, TA];
        for e = 1:numel(EMG)
            for k = 1:3   
                step = steps_tested(k);
                x = []; y = []; % Clear the variable 

                x = squeeze(step_sec{sub}(k,:)); 
                if EMG_compl_step == true
                    y = squeeze(step_EMG{sub}(EMG(e),k,:)); 
                else 
                    y = squeeze(depended_value{sub}(EMG(e),step,:)); 
                end 

                subplot(2,5,k+(e-1)*5);  hold on
                if k == 1; ylabel(labels(EMG(e))); end
                plot(x,y,'x')

            end %step
            x_all = []; y_all = [];
            x_all = squeeze(step_sec{sub}(1:3,:));
            if EMG_compl_step == true
                y_all = []; y_all = squeeze(step_EMG{sub}(EMG(e),1:3,:));
            else 
                y_all = []; y_all = squeeze(depended_value{sub}(EMG(e),[2,4,6],:));
            end 

            subplot(2,5,4+(e-1)*5:5+(e-1)*5); hold on; 
            plot(x_all(:) , y_all(:), 'x')
        end %emg
    end %sub



    
     % Set y-limits and x-limits on all subplots 
    ax = findobj(gcf, 'type', 'axes');
    ylims = get(ax, 'YLim'); 
    xlims = get(ax, 'XLim'); 
    [~, idx_y_ta]  = max(cellfun(@(x) diff(x), ylims(1:4)));
    [~, idx_y_sol] = max(cellfun(@(x) diff(x), ylims(5:8)));
    [~, idx_x_ta]  = max(cellfun(@(x) diff(x), xlims(1:4)));
    [~, idx_x_sol] = max(cellfun(@(x) diff(x), xlims(5:8)));
    idx_y_sol = idx_y_sol+4; 
    idx_x_sol = idx_x_sol+4; 
    for i = 1:numel(ax)
        if any(i == 1:4)
            set(ax(i), 'YLim', ylims{idx_y_ta})
            set(ax(i), 'XLim', xlims{idx_x_ta})
        elseif any(i == 5:8)  
            set(ax(i), 'YLim', ylims{idx_y_sol})
            set(ax(i), 'XLim', xlims{idx_x_sol})
        end
    end

        
            fprintf('done [ %4.2f sec ] \n', toc);
        else 
    fprintf('disable \n');
end   

2+2
%% Task 2.1 Within step adjustment of EMG acticity due to natural angle variation. (Single subject)
% Find whether the EMG activity is passively adjusted to changes in angle
%    trajectories. 
% All steps and seperated step 
% nassarro
% two plot: inden burst activitet og til max burst activitet (all subject)
fprintf('script: TASK 2.1  . . . '); tic

show_plot = false;
subject = 2; % 
protocol = CTL; 
before = 100; % [ms]
after = 0; % [ms]

pre = 1; search_area(pre,:) = [0.15; 0.60]; % predictor search window
dep = 2; search_area(dep,:) = [0.15; 0.70]; % depended search window

%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
% Load data from subject
data = total_data{1,1,subject};  
step_index = total_step{1,1,subject};
        
if show_plot
    figSize = [200 60 1000 700];
    figure('Position', figSize)
    sgtitle("Within step modulation due to natural angle variation. Subject "+ subject + newline + "{\color{blue}Graph} larger than avg. and {\color{red}Graph} less than avg.")
    
    clear win_avg_ang win_avg_sol win_avg_ta
    for step = 1:3
        % Align data needed to be plotted
        clear temp_plot
        temp_plot = cell(3,7); 
        [temp_plot{protocol,:}] = func_align(step_index{protocol}, data{proto,[1:4,6:7]}, 'sec_before', ms2sec(before), 'sec_after', ms2sec(after), 'alignStep', align_with_obtions(step));
        x_axis = temp_plot{protocol, time};
          
        % Align data needed to calculate window avg
        clear temp_data
        temp_data = cell(3,7); 
        [temp_data{protocol,:}] = func_align(step_index{protocol}, data{proto,[1:4,6:7]}, 'alignStep', align_with_obtions(step));
    
        % Defined window  
        for cc = [dep, pre]
            pct_start_index(cc) = ceil(size(temp_data{protocol,time},2)*search_area(cc,1));   % window begin in idx
            pct_end_index(cc)   = ceil(size(temp_data{protocol,time},2)*search_area(cc,2));   % window end in idx
            pct_start_sec(cc) = temp_data{protocol,time}(1,pct_start_index(cc));              % window begin in sec
            pct_end_sec(cc)   = temp_data{protocol,time}(1,pct_end_index(cc));                % window end in sec
        end 

        % Calculate average in window 
        win_avg_ang(step,:) = mean(temp_data{protocol,ANG}(:,pct_start_index(pre) : pct_end_index(pre)),2); % mean value of sweeps window   
        win_avg_sol(step,:) = mean(temp_data{protocol,SOL}(:,pct_start_index(dep):pct_end_index(dep)),2);   % mean value of sweeps window       
        win_avg_ta(step,:) = mean(temp_data{protocol,TA}(:,pct_start_index(dep):pct_end_index(dep)),2);     % mean value of sweeps window       
        
        % Sort data according 
        [win_avg_ang(step,:), win_avg_idx] = sort(win_avg_ang(step,:), 'ascend'); % sorts elements in ascending order.
        win_avg_sol(step,:) = win_avg_sol(step, win_avg_idx); % sort these with found order
        win_avg_ta(step,:) = win_avg_ta(step, win_avg_idx);   % sort these with found order

        clear lower_index mean_index upper_index
        % Sort data in groups [low, mid, up] 
        dim = size(win_avg_ang,2); % num of sweeps
        lower_index(:) = 1:floor(dim/3); 
        mean_index(:) = floor(dim/3)+1:dim-floor(dim/3); 
        upper_index(:) = dim-floor(dim/3)+1:dim; 

        % Mean plot properties
        color_mean = [150 152 158]/255;
        LineWidth_mean = 2; 
    
        % Upper and lower plot properties
        color_upper = "blue";
        color_lower = "red";
        upper_style = "REPLACE_WITH_DASH_DASH";
        lower_style = "-.";
        LineWidth_UL = 1; 
    
        % Patch properties
        y_pat = [-1000 -1000 2000 2000];
        patchcolor = [251 244 199]/255; 
        FaceAlpha = 1; 
        EdgeColor = [37 137 70]/255;
        lineWidth_patch = 2; 
        for cc = [dep, pre]
            x_pat(cc,:) = [pct_start_sec(cc), pct_end_sec(cc), pct_end_sec(cc), pct_start_sec(cc)]; 
        end 

        % Plot figures 
        % ankel
        subplot(330+step); hold on; 
        title("Step " + steps_tested(step))
        subtitle("Ankel"); 
        ylabel(labels_sec(ANG))
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(mean_index),:),1), 'LineWidth', LineWidth_mean, "color", color_mean)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(upper_index),:),1), upper_style, 'LineWidth', LineWidth_UL, "color", color_upper)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(lower_index),:),1), lower_style,'LineWidth', LineWidth_UL, "color", color_lower)
            YL = get(gca, 'YLim'); 
            ylim([YL(1) YL(2)]);
            patch(x_pat(pre,:),y_pat,patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', EdgeColor, 'LineWidth', lineWidth_patch)
            set(gca, 'Layer', 'top')
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(mean_index),:),1), 'LineWidth', LineWidth_mean, "color", color_mean)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(upper_index),:),1), upper_style, 'LineWidth', LineWidth_UL, "color", color_upper)
            plot(x_axis, mean(temp_plot{protocol, ANG}(win_avg_idx(lower_index),:),1), lower_style,'LineWidth', LineWidth_UL, "color", color_lower)
    
    
        % Soleus
        subplot(333+step); hold on; 
        subtitle(labels(SOL))
        ylabel("Soleus"+newline+"[normalized]")
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(mean_index),:),1), 'LineWidth', LineWidth_mean, "color", color_mean)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(upper_index),:),1), upper_style, 'LineWidth', LineWidth_UL, "color", color_upper)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(lower_index),:),1), lower_style,'LineWidth', LineWidth_UL, "color", color_lower)
            YL = get(gca, 'YLim'); ylim([YL(1) YL(2)]);
            patch(x_pat(dep,:),y_pat,patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', EdgeColor, 'LineWidth', lineWidth_patch)
            set(gca, 'Layer', 'top')
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(mean_index),:),1), 'LineWidth', LineWidth_mean, "color", color_mean)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(upper_index),:),1), upper_style, 'LineWidth', LineWidth_UL, "color", color_upper)
            plot(x_axis, mean(temp_plot{protocol, SOL}(win_avg_idx(lower_index),:),1), lower_style,'LineWidth', LineWidth_UL, "color", color_lower)
    
        % Tibialis
        subplot(336+step); hold on;
        subtitle(labels(TA))
        ylabel("Tibialis"+newline+"[normalized]")
        xlabel(labels_sec(time))
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(mean_index),:),1), 'LineWidth', LineWidth_mean, "color", color_mean)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(upper_index),:),1), upper_style, 'LineWidth', LineWidth_UL, "color", color_upper)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(lower_index),:),1), lower_style,'LineWidth', LineWidth_UL, "color", color_lower)
            YL = get(gca, 'YLim'); ylim([YL(1) YL(2)]);
            patch(x_pat(dep,:),y_pat,patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', EdgeColor, 'LineWidth', lineWidth_patch)
            set(gca, 'Layer', 'top')
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(mean_index),:),1), 'LineWidth', LineWidth_mean, "color", color_mean)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(upper_index),:),1), upper_style, 'LineWidth', LineWidth_UL, "color", color_upper)
            plot(x_axis, mean(temp_plot{protocol, TA}(win_avg_idx(lower_index),:),1), lower_style, 'LineWidth', LineWidth_UL, "color", color_lower)
    end 
fprintf('done [ %4.2f sec ] \n', toc);
else 
fprintf('disable \n');
end   

%% Task 2.2 Within step adjustment of EMG acticity due to natural angle variation. (Single subject)
fprintf('script: TASK 2.2  . . . '); tic

show_plt = false; 

%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
if show_plt
    clear x_sol x_ta
    % Rearrange data to box plot data
    step2 = 1; step4 = 2; step6 = 3; 
    % soleus
    group_low_sol = [win_avg_sol(step2,lower_index) ; win_avg_sol(step4,lower_index) ; win_avg_sol(step6,lower_index)]';
    group_mid_sol = [win_avg_sol(step2,mean_index) ; win_avg_sol(step4,mean_index) ; win_avg_sol(step6,mean_index)]';
    group_up_sol = [win_avg_sol(step2,upper_index) ; win_avg_sol(step4,upper_index) ; win_avg_sol(step6,upper_index)]';
    x_sol = {group_low_sol, group_mid_sol, group_up_sol};
    % tibialis
    group_low_ta = [win_avg_ta(step2,lower_index) ; win_avg_ta(step4,lower_index) ; win_avg_ta(step6,lower_index)]';
    group_mid_ta = [win_avg_ta(step2,mean_index) ; win_avg_ta(step4,mean_index) ; win_avg_ta(step6,mean_index)]';
    group_up_ta = [win_avg_ta(step2,upper_index) ; win_avg_ta(step4,upper_index) ; win_avg_ta(step6,upper_index)]';
    x_ta = {group_low_ta, group_mid_ta, group_up_ta};

    % Plot data to get natural y limits
    figure(13); 
    boxplotGroup(x_sol);  
    YL_sol = get(gca, 'YLim'); 
    close 13

    figure(13); 
    boxplotGroup(x_ta);  
    YL_ta = get(gca, 'YLim'); 
    close 13
    
    % Pl
    % ot boxplot for single subject
    figure; hold on; 
        blue = 	[0 0 1]; red = [1 0 0]; gray = color_mean; 

    subplot(211)
        grpLabels = {'Step 2', 'Step 4', 'Step 6'}; 
        sublabels = {'low', 'mid', 'up'};
        boxplotGroup(x_sol,'primaryLabels',sublabels,'SecondaryLabels',grpLabels, 'interGroupSpace',2,'GroupLines',true, 'Colors',[red; gray; blue],'GroupType','betweenGroups')
        ylim([YL_sol(1) YL_sol(2)])
        ylabel("Normalized muscle activity"+newline+"Soleus")
    

    % Plot boxplot for single subject
    subplot(212);hold on; 
        title("Within step adjustment of EMG acticity due to natural angle variation",'FontName','FixedWidth')
        subtitle("Single Subject. Num: " + subject ,'FontName','FixedWidth')
        boxplotGroup(x_ta,'primaryLabels',sublabels,'SecondaryLabels',grpLabels, 'interGroupSpace',2,'GroupLines',true, 'Colors',[red; gray; blue],'GroupType','betweenGroups')
        ylim([YL_ta(1) YL_ta(2)])
        ylabel("Normalized muscle activity"+newline+"Tibialis")

fprintf('done [ %4.2f sec ] \n', toc);
else 
fprintf('disable \n');
end  

%% Task 2.3 Within step adjustment of EMG acticity due to natural angle variation. (All subject)
fprintf('script: TASK 2.3  . . . '); tic
show_plt = false; 

%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
low = 1; mid = 2; up = 3; 
step2 = 1; step4 = 2; step6 = 3; 

if show_plt
    for sub = 1:numel(names) % loop through names 
        for step = 1:3 % loop through steps
            % align data to find window avg
            clear data step_index
            data = total_data{1,1,sub};  
            step_index = total_step{1,1,sub};
            
            clear temp_data
            temp_data = cell(3,7); 
            [temp_data{protocol,:}] = func_align(step_index{protocol}, data{proto,[1:4,6:7]}, 'alignStep', align_with_obtions(step));
        
            % Defined window  
            for cc = [dep, pre]
                pct_start_index(cc) = ceil(size(temp_data{protocol,time},2)*search_area(cc,1));   % window begin in idx
                pct_end_index(cc)   = ceil(size(temp_data{protocol,time},2)*search_area(cc,2));   % window end in idx
                pct_start_sec(cc) = temp_data{protocol,time}(1,pct_start_index(cc));              % window begin in sec
                pct_end_sec(cc)   = temp_data{protocol,time}(1,pct_end_index(cc));                % window end in sec
            end 
    
            clear win_avg_ang win_avg_sol win_avg_ta
            % Calculate average in window 
            win_avg_ang(step,:) = mean(temp_data{protocol,ANG}(:,pct_start_index(pre) : pct_end_index(pre)),2); % mean value of sweeps window   
            win_avg_sol(step,:) = mean(temp_data{protocol,SOL}(:,pct_start_index(dep):pct_end_index(dep)),2);   % mean value of sweeps window       
            win_avg_ta(step,:) = mean(temp_data{protocol,TA}(:,pct_start_index(dep):pct_end_index(dep)),2);     % mean value of sweeps window       
        
             % Sort data according
            [win_avg_ang(step,:), win_avg_idx] = sort(win_avg_ang(step,:), 'ascend'); % sorts elements in ascending order.
            win_avg_sol(step,:) = win_avg_sol(step, win_avg_idx); % sort these with found order
            win_avg_ta(step,:) = win_avg_ta(step, win_avg_idx);   % sort these with found order
        
            clear lower_index mean_index upper_index
            % Sort data in groups [low, mid, up] 
            dim = size(win_avg_ang,2); % num of sweeps
            lower_index(:) = 1:floor(dim/3); 
            mean_index(:) = floor(dim/3)+1:dim-floor(dim/3); 
            upper_index(:) = dim-floor(dim/3)+1:dim; 
        
            % Subject mean of each subgroup
            subgroup_sol(sub, step, low) = mean(win_avg_sol(step,lower_index));
            subgroup_sol(sub, step, mid) = mean(win_avg_sol(step,mean_index));
            subgroup_sol(sub, step, up)  = mean(win_avg_sol(step,upper_index));
            subgroup_ta(sub, step, low)  = mean(win_avg_ta(step,lower_index));
            subgroup_ta(sub, step, mid)  = mean(win_avg_ta(step,mean_index));
            subgroup_ta(sub, step, up)   = mean(win_avg_ta(step,upper_index));
        end % step
    end % sub 
    
    % Rearrange data to box plot data
    step2 = 1; step4 = 2; step6 = 3; 
    group_low_sol = [subgroup_sol(:,step2,low)' ; subgroup_sol(:,step4,low)' ; subgroup_sol(:,step6,low)' ; (subgroup_sol(:,step2,low)'+subgroup_sol(:,step4,low)'+subgroup_sol(:,step6,low)')./3]';
    group_mid_sol = [subgroup_sol(:,step2,mid)' ; subgroup_sol(:,step4,mid)' ; subgroup_sol(:,step6,mid)' ; (subgroup_sol(:,step2,mid)'+subgroup_sol(:,step4,mid)'+subgroup_sol(:,step6,mid)')./3]';
    group_up_sol =  [subgroup_sol(:,step2,up)' ; subgroup_sol(:,step4,up)' ; subgroup_sol(:,step6,up)' ; (subgroup_sol(:,step2,up)'+subgroup_sol(:,step4,up)'+subgroup_sol(:,step6,up)')./3]';
    x_sol = {group_low_sol, group_mid_sol, group_up_sol};
    
    group_low_ta = [subgroup_ta(:,step2,low)' ; subgroup_ta(:,step4,low)' ; subgroup_ta(:,step6,low)'; (subgroup_ta(:,step2,low)'+subgroup_ta(:,step4,low)'+subgroup_ta(:,step6,low)')./3]';
    group_mid_ta = [subgroup_ta(:,step2,mid)' ; subgroup_ta(:,step4,mid)' ; subgroup_ta(:,step6,mid)' ; (subgroup_ta(:,step2,mid)'+subgroup_ta(:,step4,mid)'+subgroup_ta(:,step6,mid)')./3]';
    group_up_ta =  [subgroup_ta(:,step2,up)' ; subgroup_ta(:,step4,up)' ; subgroup_ta(:,step6,up)'; (subgroup_ta(:,step2,up)'+subgroup_ta(:,step4,up)'+subgroup_ta(:,step6,up)')./3]';
    x_ta = {group_low_ta, group_mid_ta, group_up_ta};

    x_all = {(group_low_sol+group_low_ta)./2, (group_mid_sol+group_mid_ta)./2, (group_up_sol+group_up_ta)./2 } ;


    % Plot boxplot for single subject
    figure; hold on; 
    blue = 	[0 0 1]; red = [1 0 0]; gray = [150 152 158]/255;

    subplot(211)
        title("Within step adjustment - All Subject",'FontName','FixedWidth')
        grpLabels = {'Step 2', 'Step 4', 'Step 6', 'All steps'}; 
        sublabels = {'low', 'mid', 'up'};
        %plot([0 4],[100 200])
        boxplotGroup(x_sol,'primaryLabels',sublabels,'SecondaryLabels',grpLabels, 'interGroupSpace',2,'GroupLines',true, 'Colors',[red; gray; blue],'GroupType','betweenGroups')
        %ylim([YL_sol(1) YL_sol(2)])
        ylim([0 0.5])
        ylabel("Normalized muscle activity"+newline+"Soleus")
    

    % Plot boxplot for single subject
    subplot(212);hold on; 
        boxplotGroup(x_ta,'primaryLabels',sublabels,'SecondaryLabels',grpLabels, 'interGroupSpace',2,'GroupLines',true, 'Colors',[red; gray; blue],'GroupType','betweenGroups')
        %ylim([YL_ta(1) YL_ta(2)]
        ylim([0 0.5])
        ylabel("Normalized muscle activity"+newline+"Tibialis")

fprintf('done [ %4.2f sec ] \n', toc);
else 
fprintf('disable \n');
end %show_plt




%% Task 3.1 Horizontal perturbation. 
% plot difference i hastighed ift soleus aktivitet som regression plot. 
% 5 første stræk mod 5 sidste stræk 

show_plt = false; 
subject = 5; 
before = 600; 
after = 200; 
xlimit = [-100 200];
firstSweep = false; 
pltDiff = false; 
oneSweep = true; 
oneSweepNum = [8,11,13,14,15,16,17,19]

%SUBJECT 2
% SOL:
% SLR : [1,16,18,19]
% MLR : [7,8,9,11,17,18]
% TA: 
% SLR : [13,16,18]
% MLR : [1,3,5,16,18]

%SUBJECT 1
% SOL 
% SLR : [2,10,12,14]
% MLR : [1,3,4,9,10,12,13,14,15,17,19]
% TA: 
% SLR : [16,18]
% MLR : [


%SUBJECT 3
% SOL 
% SLR : [2,4,8,13,14,16]
% MLR : [5,7,9,11,15]
% TA: 
% SLR : [11]
% MLR : [11,12]

%SUBJECT 5
% SOL 
% SLR : [8,18,19]
% MLR : [18]
% TA: 
% SLR : [8,11,13,14,15,16,17,19]
% MLR : [1,7]

clear offset 
switch firstSweep
    case true 
        offset(1) = 18; %30; 
        offset(2) = 13; %38;
        offset(3) = 19; %19
        offset(4) = 0;
        offset(5) = 10;  %31;
        offset(6) = 22;  %31.5;
        offset(7) = 18;  %23;
        offset(8) = 26;
    case false
        offset(1) = 30; 
        offset(2) = 38;
        offset(3) = 19;
        offset(4) = 0;
        offset(5) = 31;
        offset(6) = 31;
        offset(7) = 23;
        offset(8) = 26;
end

%  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .

if show_plt
    data = total_data{1,1,subject};  
    step_index = total_step{1,1,subject};
    type = total_type{1,1,subject}; yes = type{3}; no = type{4}; 

    clear temp_plot
    temp_plot = cell(3,7); 
    [temp_plot{HOR,:}] = func_align(step_index{HOR}, data{HOR,[1:4,6:7]}, 'sec_before', ms2sec(before), 'sec_after', ms2sec(after), 'alignStep', "four_begin");
    x_axis = sec2ms(temp_plot{HOR, time});

    %plot properties 
    no_color = [0.75, 0.75, 0.75]; 
    yes_color = "black";
    zero_color = "red"; 
    diff_color = "green"; 
    no_LineWidth = 3; 
    yes_LineWidth = 1; 
    zero_LineWidth = 1; 


    % patch properties
    y_pat = [-1000 -1000 2000 2000];
    patchcolor_slr = "blue" ; %[251 244 199]/255; 
    patchcolor_mlr = "black" ; %[251 244 199]/255; 

    FaceAlpha = 0.2; 
    EdgeColor = [37 137 70]/255;
    lineWidth_patch = 2; 
    x_pat_SLR = [offset(subject)+39 offset(subject)+59 offset(subject)+59 offset(subject)+39];
    x_pat_MLR = [offset(subject)+59 offset(subject)+79 offset(subject)+79 offset(subject)+59];
    
    dep1 = find(floor(x_axis) == x_pat_SLR(1)); dep1 = dep1(1); 
    dep2 = find(floor(x_axis) == x_pat_SLR(2)); dep2 = dep2(1); 

    depM1 = find(floor(x_axis) == x_pat_MLR(1)); depM1 = depM1(1); 
    depM2 = find(floor(x_axis) == x_pat_MLR(2)); depM2 = depM2(1); 

    pre1 = find(floor(x_axis) == offset(subject)); pre1 = pre1(1);
    pre2 = find(floor(x_axis) == offset(subject)+20); pre2 = pre2(1);

    % Check if a figure with the name 'TASK3' is open
    fig = findobj('Name', 'TASK3');
    if ~isempty(fig), close(fig); end
    figSize = [200 60 1000 700];
    figure('Name','TASK3','Position', figSize)
    sgtitle("Horizontal. Subject " + subject)
  
    sensortype = ANG; % position 
    subplot(4,4,1:3); hold on; 
        % plot formalia (411)       
        title(['{\color{gray}Control sweeps [n=' num2str(length(no)) '].} Perturbation sweeps [n=' num2str(length(yes)) '].  {\color{red} Perturbation onset ' num2str(offset(subject)) ' [ms] }' ])
        subtitle(labels(sensortype))
        ylabel(labels_ms(sensortype))
        if ~isempty(xlimit), xlim(xlimit); end      
        % plot data (411)
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), 'LineWidth',no_LineWidth, 'Color',no_color)
        if firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), 'LineWidth',no_LineWidth, 'Color',"blue")
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), 'LineWidth',yes_LineWidth, 'Color',"red")
        end 
        if pltDiff
           plot(x_axis, zeros(size(x_axis)), "color", "black")
            y =mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no(1:5),:),1);
           plot(x_axis , y, 'LineWidth',yes_LineWidth, 'Color', diff_color)
        end 
            
        if oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),'LineWidth',yes_LineWidth ,'color',yes_color)
        else
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), 'LineWidth',yes_LineWidth, 'Color',yes_color)
        end 
        YL = get(gca, 'YLim'); ylim([YL(1) YL(2)])        
        plot([offset(subject) offset(subject)],[-100 100], 'lineWidth', zero_LineWidth, 'Color',zero_color)

    
    sensortype = VEL; % velocity
    subplot(4,4,5:7); hold on; 
        % plot formalia (412)
        subtitle(labels(sensortype))
        ylabel(labels_ms(sensortype))
        if ~isempty(xlimit), xlim(xlimit); end 
        grid on
        % plot data (412)
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), 'LineWidth',no_LineWidth, 'Color',no_color)
        if firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), 'LineWidth',no_LineWidth, 'Color',"blue") % 
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), 'LineWidth',yes_LineWidth, 'Color',"red")
        end 
        if pltDiff
           y = mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no,:),1);
           plot(x_axis, zeros(size(x_axis)), "color", "black")
           plot(x_axis , y, 'LineWidth',yes_LineWidth, 'Color', diff_color)
        end 
        if oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),'LineWidth',yes_LineWidth ,'color',yes_color)
        else
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), 'LineWidth',yes_LineWidth, 'Color',yes_color)
        end 
        YL = get(gca, 'YLim'); ylim([YL(1) YL(2)])
        plot([offset(subject) offset(subject)],[-100 100], 'lineWidth', zero_LineWidth, 'Color',zero_color)

    
    sensortype = SOL; % soleus 
    subplot(4,4,9:11); hold on; 
        % plot formalia (413)
        subtitle(labels(SOL))
        ylabel(labels(sensortype))
        % plot data (413)
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), 'LineWidth',no_LineWidth, 'Color',no_color)
        if firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), 'LineWidth',no_LineWidth, 'Color',"Blue")
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), 'LineWidth',yes_LineWidth, 'Color',"red")
        end 
       if pltDiff
           y = mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no,:),1);
           plot(x_axis, zeros(size(x_axis)), "color", "black")
           plot(x_axis , y, 'LineWidth',yes_LineWidth, 'Color', diff_color)
       end 
       if oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),'LineWidth',yes_LineWidth ,'color',yes_color)
        else
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), 'LineWidth',yes_LineWidth, 'Color',yes_color)
        end 
        YL = get(gca, 'YLim'); ylim([YL(1) YL(2)])
        plot([offset(subject) offset(subject)],[-100 100], 'lineWidth', zero_LineWidth, 'Color',zero_color)
        if ~isempty(xlimit), xlim(xlimit); end 
        patch(x_pat_SLR,y_pat,patchcolor_slr,'FaceAlpha',FaceAlpha, 'EdgeColor', "none")
        patch(x_pat_MLR,y_pat,patchcolor_mlr,'FaceAlpha',FaceAlpha, 'EdgeColor', "none")

    subplot(4,4,12); hold on; 
        ylabel("avg. SOL"); 
        xlabel("avg. POS")

        clear dependSLR dependMLR predict
        if ~pltDiff
            dependSLR(:) = mean(temp_plot{HOR,sensortype}(yes,[dep1:dep2]),2); 
            dependMLR(:) = mean(temp_plot{HOR,sensortype}(yes,[depM1:depM2]),2); 
        else 
            signal = temp_plot{HOR,sensortype}(yes,:) - temp_plot{HOR,sensortype}(no(1:numel(yes)),:); 
            dependSLR(:) = mean(signal(:,[dep1:dep2]),2); 
            dependMLR(:) = mean(signal(:,[depM1:depM2]),2); 
        end
        %predict(:) = mean(temp_plot{HOR,ANG}(yes,[pre1:pre2]),2);
        predict(:) = (temp_plot{HOR,ANG}(yes,pre1) - temp_plot{HOR,ANG}(yes,pre2))/diff([pre1,pre2]);
        mdl_slr = fitlm(predict(:), dependSLR(:));   % <REPLACE_WITH_DASH_DASH- SIG
        mdl_mlr = fitlm(predict(:), dependMLR(:));   % <REPLACE_WITH_DASH_DASH- SIG
        b_slr = table2array(mdl_slr.Coefficients(1,1)); a_slr = table2array(mdl_slr.Coefficients(2,1));
        b_mlr = table2array(mdl_mlr.Coefficients(1,1)); a_mlr = table2array(mdl_mlr.Coefficients(2,1));
        linearReg_slr = @(x) x*a_slr + b_slr; 
        linearReg_mlr = @(x) x*a_mlr + b_mlr; 
        if table2array(mdl_slr.Coefficients(2,4)) < 0.05 
            plot(predict, linearReg_slr(predict), "color", "red", 'lineWidth',2)
        end
        if table2array(mdl_mlr.Coefficients(2,4)) < 0.05 
            plot(predict, linearReg_mlr(predict), "color", "red", 'lineWidth',2)
        end
        
        plot(predict, linearReg_slr(predict), "color", "blue")
        plot(predict, linearReg_mlr(predict), "color", "black")
        plot(predict, dependSLR, 'p', "color", "blue") 
        plot(predict, dependMLR, 'p', "color", "black") 
            
    
    sensortype = TA; % tibialis 
    subplot(4,4,13:15); hold on;
        % plot formalia (414)
        subtitle(labels(sensortype))
        ylabel(labels(sensortype))
        xlabel(labels_ms(time))
        % plot data (414)
        plot(x_axis , mean(temp_plot{HOR,sensortype}(no,:),1), 'LineWidth',no_LineWidth, 'Color',no_color)
        if firstSweep
            plot(x_axis , mean(temp_plot{HOR,sensortype}(no(1:5),:),1), 'LineWidth',no_LineWidth, 'Color',"blue")
            plot(x_axis , mean(temp_plot{HOR,sensortype}(yes(1:5),:),1), 'LineWidth',yes_LineWidth, 'Color',"red")
        end
        if pltDiff
           y = mean(temp_plot{HOR,sensortype}(yes,:),1) - mean(temp_plot{HOR,sensortype}(no,:),1);
           plot(x_axis, zeros(size(x_axis)), "color", "black")
           plot(x_axis , y, 'LineWidth',yes_LineWidth, 'Color', diff_color)
        end 
        if oneSweep
            plot(x_axis,temp_plot{HOR,sensortype}(yes(oneSweepNum),:))
            plot(x_axis,mean(temp_plot{HOR,sensortype}(yes(oneSweepNum),:),1),'LineWidth',yes_LineWidth ,'color',yes_color)
        else
           plot(x_axis , mean(temp_plot{HOR,sensortype}(yes,:),1), 'LineWidth',yes_LineWidth, 'Color',yes_color)
        end 
        YL = get(gca, 'YLim'); ylim([YL(1) YL(2)])
        plot([offset(subject) offset(subject)],[-100 100], 'lineWidth', zero_LineWidth, 'Color',zero_color)
        if ~isempty(xlimit), xlim(xlimit); end 
        patch(x_pat_SLR,y_pat,patchcolor_slr,'FaceAlpha',FaceAlpha, 'EdgeColor', "none")
        patch(x_pat_MLR,y_pat,patchcolor_mlr,'FaceAlpha',FaceAlpha, 'EdgeColor', "none")

    % Pos vs TA
    subplot(4,4,16); hold on; 
        clear dependSLR dependMLR predict
        if ~pltDiff
            dependSLR(:) = mean(temp_plot{HOR,sensortype}(yes,[dep1:dep2]),2); 
            dependMLR(:) = mean(temp_plot{HOR,sensortype}(yes,[depM1:depM2]),2); 
        else 
            signal = temp_plot{HOR,sensortype}(yes,:) - temp_plot{HOR,sensortype}(no(1:numel(yes)),:); 
            dependSLR(:) = mean(signal(:,[dep1:dep2]),2); 
            dependMLR(:) = mean(signal(:,[depM1:depM2]),2); 
        end
        %predict(:) = mean(temp_plot{HOR,ANG}(yes,[pre1:pre2]),2);
        predict(:) = (temp_plot{HOR,ANG}(yes,pre1) - temp_plot{HOR,ANG}(yes,pre2))/diff([pre1,pre2]);
        mdl_slr = fitlm(predict(:), dependSLR(:));   % <REPLACE_WITH_DASH_DASH- SIG
        mdl_mlr = fitlm(predict(:), dependMLR(:));   % <REPLACE_WITH_DASH_DASH- SIG
        b_slr = table2array(mdl_slr.Coefficients(1,1)); a_slr = table2array(mdl_slr.Coefficients(2,1));
        b_mlr = table2array(mdl_mlr.Coefficients(1,1)); a_mlr = table2array(mdl_mlr.Coefficients(2,1));
        p_value = table2array(mdl_slr.Coefficients(2,4)); 
        linearReg_slr = @(x) x*a_slr + b_slr; 
        linearReg_mlr = @(x) x*a_mlr + b_mlr; 
        if table2array(mdl_slr.Coefficients(2,4)) < 0.05 
            plot(predict, linearReg_slr(predict), "color", "red", 'lineWidth',2)
        end
        if table2array(mdl_mlr.Coefficients(2,4)) < 0.05 
            plot(predict, linearReg_mlr(predict), "color", "red", 'lineWidth',2)
        end
        plot(predict, linearReg_slr(predict), "color", "blue")
        plot(predict, linearReg_mlr(predict), "color", "black")
        plot(predict, dependSLR, 'p', "color", "blue") 
        plot(predict, dependMLR, 'p', "color", "black") 
        ylabel("avg. TA"); 
        xlabel("avg. POS")
end 



%% Task 3.2 Horizontal perturbation boxplot 
% Show boxplot where all subject can clearly be identified. 
show_plt = false; 
inc_sub_hor = [1,2,3,4,5,6,7,8]; 


%   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .  
cnt = 0; 
SLR = 1; MLR = 2; 
clear h_pert
h_pert = struct; 

if firstSweep
    box_dim = 1:5; 
else 
    box_dim = 1:19; 
end

if show_plt
    clear avg_CTL avg_CTL
    for sub = inc_sub_hor
        cnt = cnt + 1; 
        data = total_data{1,1,sub};  
        step_index = total_step{1,1,sub};
        type = total_type{1,1,sub}; yes = type{3}; no = type{4}; 

        clear temp_data
        temp_data = cell(3,7); 
        [temp_data{HOR,:}] = func_align(step_index{HOR}, data{HOR,[1:4,6:7]}, 'alignStep', "four_begin");

        % Define window for each subject
        SLR_begin = floor(ms2sec(offset(sub)+39)*Fs); SLR_end = floor(ms2sec(offset(sub)+59)*Fs); % [length=41]
        MLR_begin = floor(ms2sec(offset(sub)+60)*Fs); MLR_end = floor(ms2sec(offset(sub)+80)*Fs); % [length=41]

        for muscle = [SOL, TA]
            % Short lantency reflex 
            h_pert.CTL(cnt,muscle,SLR,:) = mean(temp_data{HOR,muscle}(no(box_dim) , [SLR_begin : SLR_end]),(2));  
            h_pert.HOR(cnt,muscle,SLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [SLR_begin : SLR_end]),(2)); 
    
            % Medium lantency reflex
            h_pert.CTL(cnt,muscle,MLR,:) = mean(temp_data{HOR,muscle}(no(box_dim) , [MLR_begin : MLR_end]),(2));
            h_pert.HOR(cnt,muscle,MLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [MLR_begin : MLR_end]),(2));

            if pltDiff
                h_pert.diff(cnt,muscle,SLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [SLR_begin : SLR_end]),(2)) - mean(temp_data{HOR,muscle}(no(box_dim), [SLR_begin : SLR_end]),(2)); 
                h_pert.diff(cnt,muscle,MLR,:) = mean(temp_data{HOR,muscle}(yes(box_dim), [SLR_begin : SLR_end]),(2)) - mean(temp_data{HOR,muscle}(no(box_dim), [SLR_begin : SLR_end]),(2)); 
            end 
        end
    end % sub
    
    % Box plot data arrangement, all subject 
    x_sol_control = [mean(squeeze(h_pert.CTL(:,SOL,SLR,:)),2)' ; mean(squeeze(h_pert.CTL(:,SOL,MLR,:)),2)'];
    x_sol_pert    = [mean(squeeze(h_pert.HOR(:,SOL,SLR,:)),2)' ; mean(squeeze(h_pert.HOR(:,SOL,MLR,:)),2)'];
    x_ta_control  = [mean(squeeze(h_pert.CTL(:,TA,SLR,:)),2)'  ; mean(squeeze(h_pert.CTL(:,TA,MLR,:)),2)'  ];
    x_ta_pert     = [mean(squeeze(h_pert.HOR(:,TA,SLR,:)),2)'  ; mean(squeeze(h_pert.HOR(:,TA,MLR,:)),2)'];
    box_soleus   = {x_sol_control', x_sol_pert'}; 
    box_tibialis = {x_ta_control', x_ta_pert'}; 

    % Box plot data arrangement, individuel subject 
    box_soleus_slr   = {squeeze(h_pert.CTL(:,SOL,SLR,:))',squeeze(h_pert.HOR(:,SOL,SLR,:))'};  
    box_tibialis_slr = {squeeze(h_pert.CTL(:,TA,SLR,:))',squeeze(h_pert.HOR(:,TA,SLR,:))'};  
    box_soleus_mlr   = {squeeze(h_pert.CTL(:,SOL,MLR,:))',squeeze(h_pert.HOR(:,SOL,MLR,:))'};  
    box_tibialis_mlr = {squeeze(h_pert.CTL(:,TA,MLR,:))',squeeze(h_pert.HOR(:,TA,MLR,:))'};  

    % Box plot data arrangement, difference 
    if pltDiff
        box_diff_sol = {mean(squeeze(h_pert.diff(:,muscle,SLR,:)),2),mean(squeeze(h_pert.diff(:,muscle,MLR,:)),2) };
        box_diff_ta  = {mean(squeeze(h_pert.diff(:,muscle,TA ,:)),2),mean(squeeze(h_pert.diff(:,muscle,TA ,:)),2) };
    end 
    

    % Group labels for boxplot
    sublabels = {'CTL', 'HOR'};
    grpLabels = {'1', '2','3','4','5','6','7','8','9','10','11','12'}; 
    grpLabels_conditions = {'SLR', 'MLR'};
    
    if pltDiff
 
        fig = findobj('Name', 'Difference');
        if ~isempty(fig), close(fig); end
        figure('Name','Difference') ; 
        sgtitle("Horizontal Difference. Mean(pert) - mean(control)")
        subplot(211); hold on 
            plot([0,3], [0,0], 'color', "black")
            boxplotGroup(box_diff_sol,'primaryLabels',grpLabels_conditions)
            title("Normalized Soleus EMG")
            grid on; 
        subplot(212); hold on 
            plot([0,3], [0,0], 'color', "black")
            boxplotGroup(box_diff_ta,'primaryLabels',grpLabels_conditions)
            title("Normalized Tibialis EMG")
            grid on; 
    end

    fig = findobj('Name', 'All subject');
    if ~isempty(fig), close(fig); end
    figure('Name','All subject') 
    sgtitle("Horizontal perturbation. FirstSweep: " + firstSweep)    
    subplot(211)
        boxplotGroup(box_soleus,'primaryLabels',sublabels,'SecondaryLabels',grpLabels_conditions, 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
        ylabel("Normalized"+newline+"Soleus avtivity")
    subplot(212)
        boxplotGroup(box_tibialis,'primaryLabels',sublabels,'SecondaryLabels',grpLabels_conditions, 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
        ylabel("Normalized"+newline+"Tibialis avtivity")

    % Boxplot of individuel subject 
    figSize = [100 200 1300 400];
    fig = findobj('Name', 'Indiv sub');
    if ~isempty(fig), close(fig); end
    figure('Name','Indiv sub','Position', figSize)
    sgtitle("Horizontal perturbation. FirstSweep: " + firstSweep)    
    subplot(411); 
        boxplotGroup(box_soleus_slr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(inc_sub_hor), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
        title("Short Latency reflex - Soleus")
        ylabel("SLR"+newline+"avg. Soleus")
    subplot(412)
        title("Short Latency reflex - Tibialis")
        boxplotGroup(box_tibialis_slr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(inc_sub_hor), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
        ylabel("SLR"+newline+"avg. Tibialis")
    subplot(413);
        title("Medium Latency reflex - Soleus")
        boxplotGroup(box_soleus_mlr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(inc_sub_hor), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
        ylabel("MLR"+newline+"avg. Soleus")
    subplot(414)
        title("Medium Latency reflex - Tibialis")
        boxplotGroup(box_tibialis_mlr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(inc_sub_hor), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
        ylabel("MLR"+newline+"avg. Tibialis")
        xlabel("Subject")
end 

%% Task 4.1 Vertical perturbation
fprintf('script: TASK 4.1  . . . '); tic

show_plt = false; 
show_boxplt = true; 
subject = 8; 
x_range = [-400 200]; 
plt_show = [ANG, VEL, SOL, TA]; 
box_dim = 1:11; 
savepgn = false; 

if included_vertical_data_processing

% Defined size for window-analysis
SLR = 1; MLR = 2; 
pre_search = [0 , 20]; % denoted in ms 
SLR_search = [39, 59]; % denoted in ms  
MLR_search = [60, 80]; % denoted in ms

%   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
% Load data
data = total_data_vertical{1,1,subject}; 
type = total_type_vertical{1,1,subject}; no = type{2}; yes = type{1};
x_axis = data{VER,time};

% for i=1:numel(names_indiv)
% type = total_type_vertical{1,1,i}; no = type{2}; yes = type{1};
% numel(yes)    
% end


% Patch pr operties 
patchcolor = [251 244 199]/255; 
FaceAlpha = 0.4; 
patX_predict = [pre_search(1) pre_search(2) pre_search(2) pre_search(1)];    % ms 
patX_slr     = [SLR_search(1) SLR_search(2) SLR_search(2) SLR_search(1)];    % ms
patX_mlr     = [MLR_search(1) MLR_search(2) MLR_search(2) MLR_search(1)];    % ms
patY = [-1000 -1000 1000 1000];
EdgeColor = [37 137 70]/255;
lineWidth_patch = 0.5;

if show_plt
    % Plot properties 
    color_no = [0.75, 0.75, 0.75]; 
    color_yes = "black"; 
    linewidth_no = 3; 
    linewidth_yes = 1; 
    
    
    % Check if a figure with the name 'TASK3' is open
    fig = findobj('Name', 'Vertical Perturbation');
    if ~isempty(fig), close(fig); end
    
    % Begin plot 
    figure('Name', 'Vertical Perturbation'); hold on; 
    sgtitle("Subject: " + subject)
    for i = 1:numel(plt_show)
        subplot(numel(plt_show), 1, i); hold on
        ylabel(labels_ms(plt_show(i)))
        xlim(x_range)

        plot(x_axis, mean(data{VER,plt_show(i)}(no(box_dim),:),1), 'color', color_no, "linewidth", linewidth_no)
        plot(x_axis, mean(data{VER,plt_show(i)}(yes(box_dim),:),1), 'color', color_yes, "linewidth", linewidth_yes)
        YL = get(gca, 'YLim'); ylim([YL(1) YL(2)]);
        
        if or(plt_show(i) == ANG, plt_show(i) == VEL)  
            patch(patX_predict, patY, patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', EdgeColor, 'LineWidth', lineWidth_patch)
        else
            patch(patX_slr, patY, patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', EdgeColor, 'LineWidth', lineWidth_patch)
            patch(patX_mlr, patY, patchcolor,'FaceAlpha',FaceAlpha, 'EdgeColor', EdgeColor, 'LineWidth', lineWidth_patch)
        end 

        set(gca, 'Layer', 'top') 
        plot(x_axis, mean(data{VER,plt_show(i)}(no(box_dim),:),1), 'color', color_no, "linewidth", linewidth_no)
        plot(x_axis, mean(data{VER,plt_show(i)}(yes(box_dim),:),1), 'color', color_yes, "linewidth", linewidth_yes)
    end
    filename = "Subject"+subject+".png";
    filepath = 'C:/Users/BuusA/OneDrive - Aalborg Universitet/10. semester (Kandidat)/Matlab files/png files/vertical/';
    fullpath = fullfile(filepath, filename);
    if savepgn
        saveas(gcf, fullpath, 'png'); 
    end


    if show_boxplt
        % Boxplot
        v_pert = struct; 
        for sub = 1:numel(names_indiv)
            data = total_data_vertical{1,1,sub}; 
            type = total_type_vertical{1,1,sub}; no = type{2}; yes = type{1};
            x_axis = data{VER,time};
    
            pre_search_sample = [find(pre_search(1) == x_axis), find(pre_search(2) == x_axis)];
            SLR_search_sample = [find(SLR_search(1) == x_axis), find(SLR_search(2) == x_axis)];
            MLR_search_sample = [find(MLR_search(1) == x_axis), find(MLR_search(2) == x_axis)];
    
    %         if sub== subject 
    %             figure; 
    %             subplot(211); hold on
    %             plot([SLR_search_sample(1):SLR_search_sample(2)], mean(data{VER,SOL}(no(box_dim),  [SLR_search_sample(1):SLR_search_sample(2)]),1), "color", "blue")
    %             plot([SLR_search_sample(1):SLR_search_sample(2)], mean(data{VER,SOL}(yes(box_dim), [SLR_search_sample(1):SLR_search_sample(2)]),1), "color", "black")
    % 
    %             subplot(212), hold on 
    %             plot(mean(data{VER,SOL}(no(box_dim),  :), 1), "color", "blue")
    %             plot(mean(data{VER,SOL}(yes(box_dim), :), 1), "color", "black")
    %             plot([SLR_search_sample(1), SLR_search_sample(1)], [0,3])
    %             plot([SLR_search_sample(2), SLR_search_sample(2)], [0,3])
    %         end
    
           
            for muscle = [SOL, TA]
                % Short lantency reflex 
                v_pert.CTL(sub,muscle,SLR,:) = mean(data{VER,muscle}(no(box_dim) , [SLR_search_sample(1):SLR_search_sample(2)]), 2);
                v_pert.VER(sub,muscle,SLR,:) = mean(data{VER,muscle}(yes(box_dim), [SLR_search_sample(1):SLR_search_sample(2)]), 2);
        
                % Medium lantency reflex
                v_pert.CTL(sub,muscle,MLR,:) = mean(data{VER,muscle}(no(box_dim),  [MLR_search_sample(1):MLR_search_sample(2)]), 2);
                v_pert.VER(sub,muscle,MLR,:) = mean(data{VER,muscle}(yes(box_dim), [MLR_search_sample(1):MLR_search_sample(2)]), 2);
            end
        end
    
        % Group labels for boxplot
        sublabels = {'CTL', 'VER'};
        grpLabels = {'1', '2','3','4','5','6','7','8','9','10','11','12'}; 
        grpLabels_conditions = {'SLR', 'MLR'};
    
        % Ny boxplot 
        v_box_soleus_slr   = {squeeze(v_pert.CTL(:,SOL,SLR,:))',squeeze(v_pert.VER(:,SOL,SLR,:))'};  
        v_box_soleus_mlr   = {squeeze(v_pert.CTL(:,SOL,MLR,:))',squeeze(v_pert.VER(:,SOL,MLR,:))'};  
        v_box_sol_slr_avg  = {squeeze(mean(v_pert.CTL(:,SOL,SLR,:),4)), squeeze(mean(v_pert.VER(:,SOL,SLR,:),4))};
        v_box_sol_mlr_avg  = {squeeze(mean(v_pert.CTL(:,SOL,MLR,:),4)), squeeze(mean(v_pert.VER(:,SOL,MLR,:),4))};
    
        % Ny boxplot 
        v_box_tibialis_slr   = {squeeze(v_pert.CTL(:,TA,SLR,:))',squeeze(v_pert.VER(:,TA,SLR,:))'};  
        v_box_tibialis_mlr   = {squeeze(v_pert.CTL(:,TA,MLR,:))',squeeze(v_pert.VER(:,TA,MLR,:))'};  
        v_box_ta_slr_avg  = {squeeze(mean(v_pert.CTL(:,TA,SLR,:),4)), squeeze(mean(v_pert.VER(:,TA,SLR,:),4))};
        v_box_ta_mlr_avg  = {squeeze(mean(v_pert.CTL(:,TA,MLR,:),4)), squeeze(mean(v_pert.VER(:,TA,MLR,:),4))};


    
        % Check if a figure with the name 'TASK3' is open
        fig = findobj('Name', 'Vertical box plot');
        if ~isempty(fig), close(fig); end
        
        % Begin plot 
        figure('Name', 'Vertical box plot'); hold on; 
        subplot(2,4,1:3)
            boxplotGroup(v_box_soleus_slr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(1:numel(names_indiv)), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
            title("Short lantency reflex")
            xlabel("Subject")
            ylabel("Normalized"+newline+"Soleus")
        subplot(2,4,4)
            boxplotGroup(v_box_sol_slr_avg, 'primaryLabels',sublabels)
            title("Grouped all subjects")
        subplot(2,4,5:7)
            boxplotGroup(v_box_soleus_mlr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(1:numel(names_indiv)), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
            ylabel(labels(TA))
            title("Medium lantency reflex")
            xlabel("Subject")
            ylabel("Normalized"+newline+"Soleus")
        subplot(2,4,8)
            boxplotGroup(v_box_sol_mlr_avg, 'primaryLabels',sublabels)
            title("Grouped all subjects")
   

        % Check if a figure with the name 'TASK3' is open
        fig = findobj('Name', 'Vertical box plot2');
        if ~isempty(fig), close(fig); end
        
        % Begin plot 
        figure('Name', 'Vertical box plot2'); hold on; 
        subplot(2,4,1:3)
            boxplotGroup(v_box_tibialis_slr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(1:numel(names_indiv)), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
            title("Short lantency reflex")
            xlabel("Subject")
            ylabel("Normalized"+newline+"Tibialis")
        subplot(2,4,4)
            boxplotGroup(v_box_ta_slr_avg, 'primaryLabels',sublabels)
            title("Grouped all subjects")
        subplot(2,4,5:7)
            boxplotGroup(v_box_tibialis_mlr,'primaryLabels',sublabels,'SecondaryLabels',grpLabels(1:numel(names_indiv)), 'interGroupSpace',2,'GroupLines',true,'GroupType','betweenGroups')
            ylabel(labels(TA))
            title("Medium lantency reflex")
            xlabel("Subject")
            ylabel("Normalized"+newline+"Tibialis")
        subplot(2,4,8)
            boxplotGroup(v_box_ta_mlr_avg, 'primaryLabels',sublabels)
            title("Grouped all subjects")

    end
end
end

%% Task 5.0 Pre-baseline vs Post-baseline 
% Does the spinal influence chance due to the experienced protocols. 

%% Task 5.0 Show individual Unload trials


%% Task 6.0 make foot movement graph




%% finsihed
fprintf('\n\n Processed finished \n') 

%  title(['Black graph, Sweep data. {\color{gray} Gray graph, Mean data [n=' num2str(sweepNum) '].}'])

% % Check if a figure with the name 'TASK3' is open
% fig = findobj('Name', 'Vertical Perturbation');
% % If a figure is found, close it
% if ~isempty(fig), close(fig); end





##### SOURCE END #####
--></body></html>